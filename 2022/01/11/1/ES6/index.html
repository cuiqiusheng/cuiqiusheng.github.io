<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="吾心自足，心无外物，时时可死。步步求生，纵横四海，心无挂碍。"><title>ES6 | 不着急</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ES6</h1><a id="logo" href="/.">不着急</a><p class="description">吾心自足，心无外物，时时可死。步步求生，纵横四海，心无挂碍。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/yys/"><i class="fa fa-lab"> lab</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ES6</h1><div class="post-meta">Jan 11, 2022<span> | </span><span class="category"><a href="/categories/八股文/">八股文</a></span></div><a class="disqus-comment-count" href="/2022/01/11/1/ES6/#vcomment"><span class="valine-comment-count" data-xid="/2022/01/11/1/ES6/"></span><span> 条评论</span></a><div class="post-content"><h2 id="let、const"><a href="#let、const" class="headerlink" title="let、const"></a>let、const</h2><p>let 表示变量，const 表示常量，都是块级作用域。  </p>
<ul>
<li>不存在变量提升</li>
<li>不允许重复声明</li>
</ul>
<h2 id="解构赋值，数组解构，对象解构"><a href="#解构赋值，数组解构，对象解构" class="headerlink" title="解构赋值，数组解构，对象解构"></a>解构赋值，数组解构，对象解构</h2><ul>
<li>数组解构：直接从数组中取值，按照对应位置，赋值给变量  </li>
<li>对象解构：对象解构不需要严格按照顺序取值，而只要按照变量名去取对应属性名的值  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b] = [b, a];</span><br><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ES6新增字符串操作"><a href="#ES6新增字符串操作" class="headerlink" title="ES6新增字符串操作"></a>ES6新增字符串操作</h2><ol>
<li><code>str.includes(str)</code> 返回布尔值，表示是否找到了参数字符串。</li>
<li><code>str.startsWith(str)</code> 返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><code>str.endsWith(str)</code> 返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
<li><code>str.repeat(n)</code> 方法返回一个新字符串，表示将原字符串重复n次。n为0则返回空串</li>
<li><code>str.padStart(n, str)</code>，<code>str.padEnd(n, str)</code> 字符串补全长度。如果某个字符串不够指定长度，会在头部或尾部补全。</li>
<li><code>trimStart()</code>和<code>trimEnd()</code> 与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。</li>
</ol>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>反引号包裹，用<code>${}</code>包裹变量</p>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><ol>
<li><code>Number.isFinite()</code> 用来检查一个数值是否为有限的</li>
<li><code>Number.isNaN()</code> 用来检查一个值是否为NaN</li>
<li>ES6 将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。</li>
<li><code>Number.isInteger()</code> 用来判断一个数值是否为整数。</li>
<li>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示-2^53到2^53之间范围的上下限。</li>
<li><code>Number.isSafeInteger()</code> 则是用来判断一个整数是否落在这个范围之内</li>
</ol>
<h2 id="参数默认值，剩余参数"><a href="#参数默认值，剩余参数" class="headerlink" title="参数默认值，剩余参数"></a>参数默认值，剩余参数</h2><p>参数默认值一般用在尾参数。<br>rest参数形式为(…变量名)，用于获取函数的多余参数。</p>
<h2 id="ES6新增数组操作"><a href="#ES6新增数组操作" class="headerlink" title="ES6新增数组操作"></a>ES6新增数组操作</h2><ol>
<li><code>Array.from()</code> 将对象转为数组：string，arguments, Set, Map, key是数字的对象</li>
<li><code>Array.of()</code> 用于将一组值，转换为数组。<code>Array.of(3, 11, 8) // [3,11,8]</code></li>
<li><p><code>arr.copyWithin(target, start, end)</code> 将指定位置的成员(从start到end，不包含end的成员)复制到其他位置(从target开始)（会覆盖原有成员），然后返回当前数组。  </p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。</li>
<li><p>end（可选）：到该位置前停止读取数据，默认等于数组长度。</p>
<p><code>[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]</code>  用4，5把1，2替换<br><code>[1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5]</code> 用4把1替换</p>
</li>
</ul>
</li>
<li><code>arr.find((value, index, arr) =&gt; { ... })</code> 找出第一个符合条件的数组元素，然后返回该元素</li>
<li><code>arr.findIndex((value, index, arr) =&gt; { ... })</code> 找出第一个符合条件的数组元素，然后返回该元素的位置</li>
<li><code>arr.includes()</code> 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似</li>
<li><code>arr.entries()</code>，<code>arr.keys()</code>和<code>arr.values()</code>用于遍历数组。keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</li>
<li><code>arr.flat()</code> 用于将嵌套的数组“拉平”。默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以给flat()方法的参数传入一个整数，表示想要拉平的层数。<br> <code>[1, 2, [3, 4]].flat()   //[1, 2, 3, 4]</code><br> <code>[1, 2, [3, [4, 5]]].flat()   //[1, 2, 3, [4, 5]]</code><br> <code>[1, 2, [3, [4, 5]]].flat(2)   //[1, 2, 3, 4, 5]</code>  </li>
<li><code>arr.flatMap((value, index, arr) =&gt; { ... })</code> 先执行map，然后对返回值组成的新数组执行flat()方法。</li>
</ol>
<h2 id="表达式作为属性名或方法名"><a href="#表达式作为属性名或方法名" class="headerlink" title="表达式作为属性名或方法名"></a>表达式作为属性名或方法名</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">'a'</span> + <span class="string">'bc'</span>] = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h2><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。</p>
<p>Symbol 值通过Symbol函数生成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> s <span class="comment">// "symbol"</span></span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// Symbol()</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br></pre></td></tr></table></figure></p>
<p>ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line">sym.description <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure></p>
<p>Symbol用于对象的属性名，就能保证不会出现同名的属性。<br>不能使用点运算符，这样会把他当成字符串。Symbol 值必须放在方括号之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<p><code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<p>我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<h2 id="Set-Map-WeakSet-WeakMap"><a href="#Set-Map-WeakSet-WeakMap" class="headerlink" title="Set, Map, WeakSet, WeakMap"></a>Set, Map, WeakSet, WeakMap</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。  </p>
<ul>
<li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器</li>
<li><code>Set.prototype.values()</code>：返回键值的遍历器</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>与 Set 类似，有两点不同。</p>
<ol>
<li>但WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。因此 ES6 规定 WeakSet 不可遍历。</li>
</ol>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
<ul>
<li><code>Map.prototype.size</code>：返回Map实例的成员总数。</li>
<li><code>Map.prototype.set(key, value)</code>：添加某个值，返回 Map 结构本身。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li><code>Map.prototype.get(key)</code>：读取key对应的键值，如果找不到key，返回undefined。</li>
<li><code>Map.prototype.delete(key)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Map.prototype.has(key)</code>：返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><code>Map.prototype.clear()</code>：清除所有成员，没有返回值。</li>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器</li>
<li><code>Map.prototype.entries()</code>：返回键值对的遍历器</li>
<li><code>Map.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>与上面的WeakSet类似</p>
<h3 id="WeakSet-WeakMap的key被垃圾处理器回收了，访问get会是什么表现"><a href="#WeakSet-WeakMap的key被垃圾处理器回收了，访问get会是什么表现" class="headerlink" title="WeakSet/WeakMap的key被垃圾处理器回收了，访问get会是什么表现"></a>WeakSet/WeakMap的key被垃圾处理器回收了，访问get会是什么表现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">ws.add(obj);</span><br><span class="line">map.set(obj, <span class="string">'test'</span>);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 模拟垃圾回收，或者手动在chrom &gt; devtools &gt; performance &gt; collect garbage</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ws); <span class="comment">// WeakSet &#123;&#125;</span></span><br><span class="line">ws.has(obj); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// WeakMap &#123;&#125;</span></span><br><span class="line">map.get(obj); <span class="comment">// undefined</span></span><br><span class="line">map.has(obj); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="用-Set-获取两个数组的并集，交集，差集，补集"><a href="#用-Set-获取两个数组的并集，交集，差集，补集" class="headerlink" title="用 Set 获取两个数组的并集，交集，差集，补集"></a>用 Set 获取两个数组的并集，交集，差集，补集</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]));</span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(a)).filter(<span class="function"><span class="params">x</span> =&gt;</span> b.includes(x));</span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(a)).filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.includes(x));</span><br><span class="line"><span class="comment">// 补集</span></span><br><span class="line"><span class="keyword">let</span> complement = [...a.filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.includes(x)), ...b.filter(<span class="function"><span class="params">x</span> =&gt;</span> !a.includes(x))];</span><br></pre></td></tr></table></figure>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<p>Proxy属于一种“元编程“, 实际上重载了点运算符。</p>
<p>生成 Proxy 实例: <code>var proxy = new Proxy(target, handler);</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, property, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        <span class="built_in">console</span>.log(property);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="built_in">console</span>.log(receiver);</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, property, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>(target, property, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        <span class="built_in">console</span>.log(property);</span><br><span class="line">        <span class="built_in">console</span>.log(receiver);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.test = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Proxy &#123;&#125;</span></span><br><span class="line">proxy.test</span><br><span class="line"><span class="comment">// &#123;test: 1&#125;</span></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// Proxy &#123;test: 1&#125;</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">target </span><br><span class="line"><span class="comment">// &#123;test: 1&#125;</span></span><br><span class="line">target.test2 = <span class="number">2</span></span><br><span class="line">target </span><br><span class="line"><span class="comment">// &#123;test: 1, test2: 2&#125;</span></span><br><span class="line">proxy</span><br><span class="line"><span class="comment">// Proxy &#123;test: 1, test2: 2&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。谁调用指向谁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() <span class="comment">// false</span></span><br><span class="line">proxy.m()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>一共支持13种拦截操作</p>
<ol>
<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li>
<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ol>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>Reflect对象一般搭配Proxy使用，Reflect对象的设计目的有这样几个  </p>
<ol>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</li>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
</ol>
<h3 id="Proxy中为啥要搭配Reflect使用。"><a href="#Proxy中为啥要搭配Reflect使用。" class="headerlink" title="Proxy中为啥要搭配Reflect使用。"></a>Proxy中为啥要搭配Reflect使用。</h3><p>在复杂的使用场景保持正确的上下文和this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, property, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, property, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>(target, property, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>有13个静态方法  </p>
<ol>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ol>
<p>上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。</p>
<p>Reflect.apply，可以改写以前的call, apply写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	name: <span class="string">'test'</span>,</span><br><span class="line">	say() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">	name: <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line">a.say.call(b) <span class="comment">//b</span></span><br><span class="line">a.say.apply(b) <span class="comment">//b</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(a.say, b, []) <span class="comment">//b</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Promise有哪些方法"><a href="#Promise有哪些方法" class="headerlink" title="Promise有哪些方法"></a>Promise有哪些方法</h2><ul>
<li><code>Promise.all([p1, p2, p3])</code> 都resolve则resolve, 有一个reject即rejefct</li>
<li><code>Promise.race([p1, p2, p3])</code> 有任何一个先resolve，或者reject，则整体即为resolve或reject</li>
<li><code>Promise.allSettled([p1, p2, p3])</code> ES2020引入。只有等到所有这些参数实例都返回结果，不管是resolve还是rejected，整体才会结束。一旦结束，状态总是resolve，值是各个promise的状态和value;</li>
<li><code>Promise.any([p1, p2, p3])</code> 目前还是stage3提案。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。跟Promise.race()的不同就是不会因为某个 Promise 变成rejected状态而结束。</li>
<li><code>Promise.resolve()</code> 将现有对象转为 Promise 对象,并且是resolve状态。不带参数，直接返回一个resolved状态的 Promise 对象。</li>
<li><code>Promise.reject()</code> 返回一个新的 Promise 实例，该实例的状态为rejected。</li>
<li><code>Promise.prototype.then()</code> 为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</li>
<li><code>Promise.prototype.catch()</code> 如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的成功或者失败的回调函数，如果运行中抛出错误，也会被catch方法捕获。</li>
<li><code>Promise.prototype.finally()</code> 用于指定不管 Promise 对象最后状态如何，都会执行的操作。</li>
</ul>
<h2 id="Promise的执行顺序"><a href="#Promise的执行顺序" class="headerlink" title="Promise的执行顺序"></a>Promise的执行顺序</h2><ol>
<li>同步代码最先执行  </li>
<li>Promise 新建后立即执行, Promise.resolve()也是立即执行</li>
<li>then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行</li>
<li>setTimeout等异步方法会最后执行。</li>
<li>如果有async/await，await关键字后面的方法也是立即执行，执行完之后会继续执行全局同步代码，等同步代码执行完毕, 才会将await语句后面的代码放入微任务队列。不是立即放入。  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">await</span> async2()</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> async3()</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1, 3, 8, 9, 4, 5, 7, 6, 2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h2><ol>
<li>首先Promise是一个类，可以new出来实例</li>
<li>new的时候，接收一个参数 <code>new Promise((resolve, reject)=&gt;{})</code>，我们叫这个参数为executor，</li>
<li>Promise会立即执行，也就是executor会立即执行。</li>
<li>executor是一个函数，可以接收resolve和reject两个参数。</li>
<li>resolve, reject两个参数可以单独执行，所以他是两个方法</li>
<li>Promise有三种状态pending、fulfilled、rejected，pending可以变为其他状态，但其他状态不可再变</li>
<li>Promise还会有返回值，表示成功之后的值或者失败的原因。</li>
<li>resolve(value)会将Promise的状态变为fulfilled，并且将promise的值设为value</li>
<li>reject(reason)会将Promise的状态变为rejected, 并将promise的值设为reason</li>
<li>如果excutor出错，直接变为rejected状态。</li>
<li>Promise实例有then方法，可以接收fulfilled或者rejected的回调</li>
</ol>
<h3 id="总结就是，一个-class-类，-有个constructor，参数是excutor，构造函数中执行这个excutor，excutor接受参数resolve，-reject，用try-catch包裹执行。同时有5个实例属性，status-value-reason-successCallbacks-errorCallbacks。两个实例方法，-then-catch。then里面判断状态，执行或者放入数组，catch中调用then"><a href="#总结就是，一个-class-类，-有个constructor，参数是excutor，构造函数中执行这个excutor，excutor接受参数resolve，-reject，用try-catch包裹执行。同时有5个实例属性，status-value-reason-successCallbacks-errorCallbacks。两个实例方法，-then-catch。then里面判断状态，执行或者放入数组，catch中调用then" class="headerlink" title="总结就是，一个 class 类， 有个constructor，参数是excutor，构造函数中执行这个excutor，excutor接受参数resolve， reject，用try catch包裹执行。同时有5个实例属性，status,value, reason, successCallbacks, errorCallbacks。两个实例方法， then, catch。then里面判断状态，执行或者放入数组，catch中调用then"></a>总结就是，一个 class 类， 有个constructor，参数是excutor，构造函数中执行这个excutor，excutor接受参数resolve， reject，用try catch包裹执行。同时有5个实例属性，status,value, reason, successCallbacks, errorCallbacks。两个实例方法， then, catch。then里面判断状态，执行或者放入数组，catch中调用then</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(excutor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="comment">// 存放成功的回调</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="comment">// 存放失败的回调</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks= [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = <span class="string">'fullfilled'</span>;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="comment">// 依次将对应的函数执行</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = <span class="string">'rejected'</span>;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            excutor(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    then(success, error) &#123;</span><br><span class="line">        <span class="comment">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span> &amp;&amp; success) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> success(<span class="keyword">this</span>.value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span> &amp;&amp; error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> error(<span class="keyword">this</span>.reason))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'fullfilled'</span> &amp;&amp; success) &#123;</span><br><span class="line">            success(<span class="keyword">this</span>.result)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span> &amp;&amp; error) &#123;</span><br><span class="line">            error(<span class="keyword">this</span>.reason)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">this</span>.then(<span class="literal">null</span>, error);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手写实现-Promise-all"><a href="#手写实现-Promise-all" class="headerlink" title="手写实现 Promise.all"></a>手写实现 Promise.all</h2><ol>
<li>Promise.all的返回值也是一个Promise</li>
<li>返回一个对应的数组，数组下标的值对应其Promise的结果。</li>
<li>如果有Promise 被reject, Promise.all失败。都成功才成功。</li>
<li>参数数组里面可以是promise，也可是普通数据。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAll</span>(<span class="params">promiseList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;promiseList.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 不能直接promiseList[i].then()， 因为promiseList[i]可能是普通数据</span></span><br><span class="line">            <span class="built_in">Promise</span>.resolve(promiseList[i]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                result[i] = res;</span><br><span class="line">                <span class="keyword">if</span> (count === promiseList.length) &#123;</span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">                reject(e)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="如何限制-Promise-请求并发数"><a href="#如何限制-Promise-请求并发数" class="headerlink" title="如何限制 Promise 请求并发数"></a>如何限制 Promise 请求并发数</h2><p>通过Promise.all()实现</p>
<ol>
<li>初始化limit个Promise对象，作为Promise.all的参数</li>
<li>Promise.all，执行这limit个数的Promise，等待resolve</li>
<li>重复步骤1，2</li>
</ol>
<h2 id="Iterator遍历器和for…of"><a href="#Iterator遍历器和for…of" class="headerlink" title="Iterator遍历器和for…of"></a>Iterator遍历器和for…of</h2><p>Iterator它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。用for…of遍历。</p>
<p>当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p>原生具备 Iterator 接口的数据结构如下：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 函数是一个状态机，封装了多个内部状态。<br>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。<br>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象。<br>调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line">test.next(); <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">test.next(); <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">test.next(); <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">test.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>
<p>for…of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure></p>
<p>next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象。所以上面代码的return语句返回的6，不包括在for…of循环之中。</p>
<p>Generator 函数的执行必须靠执行器，所以才有了co模块。co 模块可以让你不用编写 Generator 函数的执行器。Generator 函数只要传入co函数，就会自动执行。co函数返回一个Promise对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h2><p>async就是 Generator 函数的语法糖。</p>
<ol>
<li>async函数自带执行器。async函数的执行，与普通函数一模一样。</li>
<li>async和await，比起星号和yield，语义更清楚。</li>
<li>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li>
<li>async函数的返回值是 Promise 对象，比 Generator 函数的返回值是 Iterator 对象方便多了</li>
</ol>
<p>async/await的注意事项：</p>
<ol>
<li>async函数返回一个 Promise 对象。</li>
<li>async函数内部return语句返回的值，会成为then方法回调函数的参数。</li>
<li>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。</li>
<li>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到</li>
<li>把await命令放在try…catch代码块中</li>
<li>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li>
<li>await命令只能用在async函数之中，如果用在普通函数，就会报错。</li>
<li>async 函数可以保留运行堆栈。</li>
</ol>
<h2 id="await能不能被return，return-await-promise-和-return-promise的区别"><a href="#await能不能被return，return-await-promise-和-return-promise的区别" class="headerlink" title="await能不能被return，return await promise 和 return promise的区别"></a>await能不能被return，return await promise 和 return promise的区别</h2><p><a href="https://stackoverflow.com/questions/38708550/difference-between-return-await-promise-and-return-promise" target="_blank" rel="noopener">https://stackoverflow.com/questions/38708550/difference-between-return-await-promise-and-return-promise</a></p>
<ol>
<li>大体上没啥区别，效果一样</li>
<li>一般await用try catch包裹，如果两个都用try catch包裹，如果promise reject，return await promise会走到catch， return promise不会。</li>
</ol>
<h2 id="Class与继承"><a href="#Class与继承" class="headerlink" title="Class与继承"></a>Class与继承</h2><h3 id="class的用法"><a href="#class的用法" class="headerlink" title="class的用法"></a>class的用法</h3><ol>
<li>class声明类</li>
<li>constructor为构造方法，可传参。constructor方法是类的默认方法，如果没有显式定义，一个空的constructor方法会被默认添加。</li>
<li>类可以定义实例属性和方法</li>
<li>类内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</li>
<li>类的属性名，可以采用表达式</li>
<li>类的方法内部如果含有this，它默认指向类的实例</li>
<li>用static表示静态方法。静态方法可以被子类继承。如果静态方法包含this关键字，这个this指的是类，而不是实例。</li>
<li>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</li>
<li>目前只能通过在类名上面加属性。现在有一个提案在实例属性的前面，加上static关键字来表示静态属性。</li>
<li>私有属性和私有方法，名字前面加下划线。或者用Symbol值命名私有方法名。因为Symbol作为属性名，不会被遍历出来。但可以用getOwnPropertySymbols遍历出来。</li>
<li>ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过extends关键字实现继承。  </p>
<p>子类必须在constructor方法中调用super方法。只有调用super之后，才可以使用this关键字，否则会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'father'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'son'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES5的继承，子类必须调用父类的call，同时子类原型prototype是父类实例，子类原型prototype的构造函数是本身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Father = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'爸爸'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Son = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'儿子'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure></p>
<h3 id="class中的原型链"><a href="#class中的原型链" class="headerlink" title="class中的原型链"></a>class中的原型链</h3><p>同时存在两条继承链：</p>
<ol>
<li>子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</li>
<li>子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br><span class="line">a.__proto__ === A.prototype <span class="comment">// true</span></span><br><span class="line">b.__proto__ === B.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="class-中的箭头函数和普通函数有什么区别，如下"><a href="#class-中的箭头函数和普通函数有什么区别，如下" class="headerlink" title="class 中的箭头函数和普通函数有什么区别，如下"></a>class 中的箭头函数和普通函数有什么区别，如下</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  fn() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">  f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure>
<ol>
<li>两种写法都是原型方法，实例可以调用。</li>
<li>普通函数写法，<code>a.fn()</code>这样调用没问题，如果是改下引用， <code>let b = a.fn; b();</code>这样调用会报错。</li>
<li>箭头函数会绑定this，以后不管什么方式调用this都不会丢失。</li>
</ol>
</div><div class="tags"><a href="/tags/ES6/">ES6</a></div><div class="post-nav"><a class="pre" href="/2022/01/11/1/性能优化/">性能优化</a><a class="next" href="/2022/01/11/1/浏览器/">浏览器</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'cXa2hNBumN2DUEHc5sMwqmAR-gzGzoHsz',
  appKey:'k25vMV7ayuuHBhTaLWsiFGXp',
  placeholder:'ヾﾉ≧∀≦)o欢迎你的评论~~~',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://cuiqs.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/八股文/">八股文</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/">学习</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/防火墙/" style="font-size: 15px;">防火墙</a> <a href="/tags/OKR/" style="font-size: 15px;">OKR</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/浏览器/" style="font-size: 15px;">浏览器</a> <a href="/tags/Webkit/" style="font-size: 15px;">Webkit</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/virtualenv/" style="font-size: 15px;">virtualenv</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/ubuntu-nginx/" style="font-size: 15px;">ubuntu nginx</a> <a href="/tags/抓取网页/" style="font-size: 15px;">抓取网页</a> <a href="/tags/webpack4/" style="font-size: 15px;">webpack4</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/Webpack/" style="font-size: 15px;">Webpack</a> <a href="/tags/Vue3-Vite/" style="font-size: 15px;">Vue3-Vite</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/网络与安全/" style="font-size: 15px;">网络与安全</a> <a href="/tags/软性/" style="font-size: 15px;">软性</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/CSS/">CSS</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/HTML/">HTML</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/React/">React</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/Webpack/">Webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/vue3-vite/">Vue3-Vite</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/Vue/">Vue</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/JavaScript/">JavaScript</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/性能优化/">性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/ES6/">ES6</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/浏览器/">浏览器</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">不着急.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>