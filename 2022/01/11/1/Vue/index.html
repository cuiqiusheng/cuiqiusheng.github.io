<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="吾心自足，心无外物，时时可死。步步求生，纵横四海，心无挂碍。"><title>Vue | 不着急</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Vue</h1><a id="logo" href="/.">不着急</a><p class="description">吾心自足，心无外物，时时可死。步步求生，纵横四海，心无挂碍。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/yys/"><i class="fa fa-lab"> lab</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Vue</h1><div class="post-meta">Jan 11, 2022<span> | </span><span class="category"><a href="/categories/八股文/">八股文</a></span></div><a class="disqus-comment-count" href="/2022/01/11/1/Vue/#vcomment"><span class="valine-comment-count" data-xid="/2022/01/11/1/Vue/"></span><span> 条评论</span></a><div class="post-content"><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>创建前/后, 载入前/后, 更新前/后, 销毁前/后<br>beforeCreate/created, beforeMount/mounted, beforeUpdate/updated, beforeDestroy/destroyed<br>keep-alive 组件激活时 activated，keep-alive 组件停用时 deactivated</p>
<h2 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h2><p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这四个钩子</p>
<h2 id="DOM渲染在哪个周期中就已经完成？"><a href="#DOM渲染在哪个周期中就已经完成？" class="headerlink" title="DOM渲染在哪个周期中就已经完成？"></a>DOM渲染在哪个周期中就已经完成？</h2><p>在 mounted 中就已经完成了</p>
<h2 id="每个生命周期适合哪些场景？"><a href="#每个生命周期适合哪些场景？" class="headerlink" title="每个生命周期适合哪些场景？"></a>每个生命周期适合哪些场景？</h2><ul>
<li>beforecreate : 此时data和method都还没初始化，可以在这加个loading事件，在加载实例时触发，在created时进行移除。</li>
<li>created : 初始化完成时的事件写在这里，需要异步请求数据的方法可以在此时执行，完成数据的初始化。</li>
<li>mounted : 当需要操作dom的时候执行</li>
<li>updated : 当数据更新要做统一业务处理的时候</li>
</ul>
<h2 id="Vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序</h2><p>组件的调用顺序都是先父后子</p>
<p>加载渲染：  </p>
<ul>
<li>父beforeCreate –&gt; 父created –&gt; 父beforeMounted –&gt; 子beforeCreate –&gt; 子created –&gt; 子beforeMounted –&gt; 子mounted –&gt;父mounted  </li>
</ul>
<p>父组件更新：  </p>
<ul>
<li>影响到子组件： 父beforeUpdate -&gt; 子beforeUpdate-&gt;子updated -&gt; 父updted</li>
<li>不影响子组件： 父beforeUpdate -&gt; 父updated</li>
</ul>
<p>子组件更新：  </p>
<ul>
<li>父beforeUpdate –&gt; 子beforeUpdate –&gt; 子updated –&gt; 父updated  </li>
</ul>
<p>父组件销毁：  </p>
<ul>
<li>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li>
</ul>
<p>子组件销毁：  </p>
<ul>
<li>子 beforeDestroy -&gt; 子 destroyed</li>
</ul>
<h2 id="beforeCreate-的时候能拿到-Vue-实例么"><a href="#beforeCreate-的时候能拿到-Vue-实例么" class="headerlink" title="beforeCreate 的时候能拿到 Vue 实例么"></a>beforeCreate 的时候能拿到 Vue 实例么</h2><p>可以拿到组件实例，也就是可以用this。但是不能获取到data和methods。如果想强行获取data，可以用this.$options.data()</p>
<h2 id="什么情况下会触发组件销毁，销毁的时候会卸载自定义事件和原生事件么"><a href="#什么情况下会触发组件销毁，销毁的时候会卸载自定义事件和原生事件么" class="headerlink" title="什么情况下会触发组件销毁，销毁的时候会卸载自定义事件和原生事件么"></a>什么情况下会触发组件销毁，销毁的时候会卸载自定义事件和原生事件么</h2><ul>
<li>页面关闭</li>
<li>路由切换（没有keep-alive时）</li>
<li>v-if</li>
</ul>
<p>Vue本身的一些自定义事件监听，比如@click, @blur等会自动销毁，但是原生的document.addEventListener事件比如scroll，keydown，keyup，vue监测不到，无法移除监听，你可以自己销毁。</p>
<p>其实组件销毁后DOM元素也被移除，根据JS的垃圾回收机制，节点的销毁，会顺带把该节点所有的监听事件置空，所以绑定在DOM元素上的事件自然也就被移除了。但是绑定的是document的话，因为document对象没有被清楚，所以事件没有被卸载。</p>
<h2 id="哪个生命周期调用异步请求"><a href="#哪个生命周期调用异步请求" class="headerlink" title="哪个生命周期调用异步请求"></a>哪个生命周期调用异步请求</h2><p>created、beforeMount、mounted 中都可以，因为此时data已经创建。一般在created中。</p>
<h2 id="父组件怎么监听子组件的生命周期"><a href="#父组件怎么监听子组件的生命周期" class="headerlink" title="父组件怎么监听子组件的生命周期"></a>父组件怎么监听子组件的生命周期</h2><ol>
<li><p>子组件生命周期中emit，在子组件上监听，并触发父组件的方法。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;Child @mounted=<span class="string">"doSomething"</span>/&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">"mounted"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用@hook监听</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Parent.vue</span></span><br><span class="line">&lt;Child @hook:mounted=<span class="string">"doSomething"</span> &gt;<span class="xml"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  Child.vue</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子组件触发 mounted 钩子函数 ...'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="v-show与v-if区别"><a href="#v-show与v-if区别" class="headerlink" title="v-show与v-if区别"></a>v-show与v-if区别</h2><ol>
<li>v-show是css切换,display:none。</li>
<li>v-if是完整的销毁和重新创建</li>
</ol>
<p>频繁切换时用v-show，运行时较少改变时用v-if</p>
<h2 id="computed-watch"><a href="#computed-watch" class="headerlink" title="computed watch"></a>computed watch</h2><p>computed和watch都起到监听/依赖一个数据，并执行相应操作</p>
<ol>
<li>computed：<ul>
<li>计算属性，值会缓存，下次使用此属性，直接使用缓存的值。它依赖的属性值变化后，此值会重新计算。</li>
<li>可以依赖多个属性</li>
<li>需要有return</li>
<li>不支持异步</li>
</ul>
</li>
<li>watch：<ul>
<li>数据的监听，监听的数据变化后，回调函数会执行。页面重新渲染时值不变化也会执行。</li>
<li>支持异步</li>
<li>immediate：watch默认在数据从无到有的过程是不进行监听的，如果需要监听这个过程，可将immediate设置为true；</li>
<li>deep：若对象没有改变，但是对象内部的属性改变了，需要监听此变化就将deep设置为true。</li>
</ul>
</li>
</ol>
<h2 id="常用指令有哪些"><a href="#常用指令有哪些" class="headerlink" title="常用指令有哪些"></a>常用指令有哪些</h2><p><code>v-if v-else v-for v-show v-modal</code></p>
<h2 id="绑定class的方法"><a href="#绑定class的方法" class="headerlink" title="绑定class的方法"></a>绑定class的方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对象语法，直接传给class一个对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, test1: isActive&#125;"</span>&gt;</span>通过对象语法绑定class<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对象语法，传给class一个计算属性，这个计算属性会返回一个对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span>通过对象语法绑定class<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组语法，直接传给class一个数组，数组里的每个值都是data值，代表一个class名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:class</span>=<span class="string">"[className1, className2]"</span>&gt;</span>通过数组语法绑定class<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数组语法，三元表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? className1 : className2]"</span>&gt;</span>通过数组语法绑定class<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;component v-bind:is=<span class="string">"currentTabComponent"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="直接给一个数组项赋值，Vue-能检测到变化吗？怎么解决？"><a href="#直接给一个数组项赋值，Vue-能检测到变化吗？怎么解决？" class="headerlink" title="直接给一个数组项赋值，Vue 能检测到变化吗？怎么解决？"></a>直接给一个数组项赋值，Vue 能检测到变化吗？怎么解决？</h2><p>不能检测到以下变化：<br>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code><br>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code>  </p>
<p>解决方法：  </p>
<ul>
<li>解决第一种问题：<br><code>vm.$set(vm.items, indexOfItem, newValue)</code><br><code>vm.items.splice(indexOfItem, 1, newValue)</code>  </li>
<li>解决第二种问题：<br><code>vm.items.splice(newLength)</code> </li>
</ul>
<h2 id="Vue-如何实现的数组的监听，为什么-Vue-没有对数组下标修改做劫持"><a href="#Vue-如何实现的数组的监听，为什么-Vue-没有对数组下标修改做劫持" class="headerlink" title="Vue 如何实现的数组的监听，为什么 Vue 没有对数组下标修改做劫持"></a>Vue 如何实现的数组的监听，为什么 Vue 没有对数组下标修改做劫持</h2><p>重写数组的方法。不对数组下标做劫持就是因为性能问题。</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ol>
<li><p>props/$emit 父子通信<br> 如果子组件需要修改父组件传进来的props，可以用.sync来减少父组件监听和修改的代码</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;child :val=<span class="string">"name"</span> @update=<span class="string">"modify"</span>&gt;</span><br><span class="line">modify(newVal)&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=newVal</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line">&lt;input :value=val @input=<span class="string">"$emit('update', $event.target.value)"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="comment">// 父组件中，省略了写监听函数</span></span><br><span class="line">&lt;child :val.sync=<span class="string">"name"</span>&gt;</span><br><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line">&lt;input :value=val @input=<span class="string">"$emit('update:val', $event.target.value)"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用vuex 父子，兄弟，隔代都可以用</p>
</li>
<li><p>EventBus 父子，兄弟，隔代都可以用</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br><span class="line">EventBus.$emit(<span class="string">"aMsg"</span>, <span class="string">'来自A页面的消息'</span>);</span><br><span class="line">EventBus.$on(<span class="string">"aMsg"</span>, (msg) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.msg = msg;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>provide/inject 隔代通信<br> 祖先组件中通过 provide 来提供变量，然后在子孙组件中通过 inject 来注入变量  </p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 祖先</span></span><br><span class="line">provide: &#123;</span><br><span class="line">  test: <span class="string">"demo"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子孙</span></span><br><span class="line">inject: [<span class="string">'test'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$attrs/$listeners</code> 隔代通信</p>
<ul>
<li><p>$attrs：当子组件的props中没有声明父组件传下来的prop属性时，那么父组件传下来的prop属性会被保存在子组件的$attrs属性上( class 和 style 除外 )。<br>子组件加了inheritAttrs:false，DOM上就不会继承未声明的props。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line">&lt;child :foo=<span class="string">"foo"</span> :coo=<span class="string">"coo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子，继承了所有属性并传给下一代</span></span><br><span class="line">&lt;p&gt;attrs:&#123;&#123;$attrs&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;grandChild v-bind="$attrs"&gt;&lt;/g</span>randChild&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 孙子，只声明了coo，并设置inheritAttrs: false表示不继承</span></span><br><span class="line">props:[<span class="string">"coo"</span>],</span><br><span class="line">inheritAttrs:<span class="literal">false</span></span><br><span class="line">&lt;p&gt;coo:&#123;&#123;coo&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>$listeners：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line">&lt;child @parentTest=<span class="string">"parentTestMethod"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">parentTestMethod(value)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子，相当于也监听了事件</span></span><br><span class="line">&lt;grandChild v-on=<span class="string">"$listeners"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">grandChild</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 孙子</span></span><br><span class="line">&lt;button @click=<span class="string">"test"</span>&gt;我要发射火箭&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">test()&#123;</span></span><br><span class="line"><span class="regexp">    this.$emit("parentTest",'test');</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>ref 与 $parent / $children 父子通信  </p>
<ul>
<li>使用 this.$parent 查找当前组件的父组件实例。</li>
<li>使用 this.$children 查找当前组件的直接子组件，可以遍历全部子组件，需要注意 $children 并不保证顺序，也不是响应式的。</li>
<li>使用 this.$refs 查找命名子组件。</li>
<li>使用 this.$root 查找根组件，并可以配合$children遍历全部组件。</li>
</ul>
</li>
</ol>
<h2 id="provide-inject实现原理"><a href="#provide-inject实现原理" class="headerlink" title="provide/inject实现原理"></a>provide/inject实现原理</h2><p>通过原型链实现的传参。</p>
<ul>
<li><p>provides</p>
<p>  实例上挂载的provides要么是直接拿的父实例上的provides，要么是创建的一个原型指向父实例provides的对象。</p>
</li>
<li><p>inject  </p>
<p>  若当前实例没有父实例则取根实例上的provides否则取父实例上的provides。<br>  拿到provides后，会遍历原型上的属性去取内容。</p>
</li>
</ul>
<h2 id="template-和-jsx-的优缺点"><a href="#template-和-jsx-的优缺点" class="headerlink" title="template 和 jsx 的优缺点"></a>template 和 jsx 的优缺点</h2><h3 id="template"><a href="#template" class="headerlink" title="template:"></a>template:</h3><p>优点：</p>
<ul>
<li>基于 dom 结构，方便，易读，易上手，学习成本低</li>
</ul>
<p>缺点：</p>
<ul>
<li>不够灵活，只能基于提供的指令去写逻辑</li>
</ul>
<h3 id="jsx"><a href="#jsx" class="headerlink" title="jsx:"></a>jsx:</h3><p>优点：</p>
<ul>
<li>基于js语法表达各种逻辑，十分灵活</li>
</ul>
<p>缺点：</p>
<ul>
<li>可读性差，容易写的很乱</li>
<li>没有编译优化</li>
</ul>
<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><ol>
<li><p>声明式，<code>&lt;router-link to=&#39;home&#39;&gt;</code> router-link标签会渲染为<code>&lt;a&gt;</code>标签</p>
</li>
<li><p>编程式导航，比如<code>this.$router.push(&#39;/home&#39;)</code></p>
</li>
</ol>
<h2 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h2><ol>
<li>全局前置守卫 <code>router.beforeEach((to, from, next) =&gt; {...})</code></li>
<li>全局解析守卫 <code>router.beforeResolve((to, from, next) =&gt; {...})</code>，和router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</li>
<li>全局后置钩子 <code>router.afterEach((to, from) =&gt; {...})</code>，没有 next 函数也不会改变导航本身</li>
<li>路由独享守卫 <code>beforeEnter((to, from, next) =&gt; {...})</code>，在路由配置上直接定义</li>
<li>组件内的守卫<ul>
<li>beforeRouteEnter (to, from, next) {…}在渲染该组件的对应路由被confirm前调用</li>
<li>beforeRouteUpdate (to, from, next) {…}在当前路由改变，但是该组件被复用时调用</li>
<li>beforeRouteLeave (to, from, next) {…}导航离开该组件的对应路由时调用</li>
</ul>
</li>
</ol>
<h2 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h2><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫 beforeRouteLeave 守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<h2 id="MVC-MVP-MVVM"><a href="#MVC-MVP-MVVM" class="headerlink" title="MVC MVP MVVM"></a>MVC MVP MVVM</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li>View：显示数据，检测用户的行为，调用Controller执行应用逻辑。</li>
<li>Controller：应用逻辑或业务逻辑处理，并更新modal</li>
<li>Model：Model变更后，通过观察者模式通知View更新视图。<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3></li>
<li>View：对Presenter提供接口。不再依赖Modal。</li>
<li>Presenter（Supervising Controller）：和经典MVC的Controller相比，任务更加繁重，不仅要处理应用业务逻辑，还要处理同步逻辑(高层次复杂的UI操作)。</li>
<li>Model：Model变更后，通过观察者模式通知Presenter，如果有视图更新，Presenter又可能调用View的接口更新视图。<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3></li>
<li>ViewModel：内部集成了Binder(Data-binding Engine，数据绑定引擎)，将View和Model双向绑定，从而实现View或Model的自动更新。</li>
<li>View：显示数据，View的变化会通过Binder自动更新相应的Model。</li>
<li>Model：Model的变化也会被Binder监听(仍然是通过观察者模式)，一旦监听到变化，Binder就会自动实现View的更新。</li>
</ul>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><ol>
<li>数据只能从父组件流向子组件，props向下传，emit触发事件，父组件中去更新data。子组件修改props, vue 将会报错。</li>
<li>vuex的单向数据流，状态只能通过提交mutation去更改。</li>
</ol>
<h2 id="v-for循环为什么要加key"><a href="#v-for循环为什么要加key" class="headerlink" title="v-for循环为什么要加key"></a>v-for循环为什么要加key</h2><p>使用v-for更新已渲染的元素列表时,默认用”就地复用“策略;列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素。</p>
<p>从原理上来说，使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，key的作用主要是为了高效的更新虚拟DOM。</p>
<h2 id="key可以是index吗，可以是随机数吗？会有什么问题？"><a href="#key可以是index吗，可以是随机数吗？会有什么问题？" class="headerlink" title="key可以是index吗，可以是随机数吗？会有什么问题？"></a>key可以是index吗，可以是随机数吗？会有什么问题？</h2><p>判断两个节点是否为同一节点（也就是是否可复用），标准是key相同且tag相同。</p>
<ol>
<li>用index作为key，如果数组元素都变了，比如arr.reverse()，所有列表项会重新创建渲染，不会复用。</li>
<li>用index作为key，如果删除了数组第一个元素，虚拟diff的结果会是删除了最后一个元素，其他元素内容改变，导致所有列表项会重新创建渲染，不会复用。</li>
<li>用index作为key时，在对数据进行，逆序添加，逆序删除等破坏顺序的操作时，会产生没必要的真实 DOM更新，从而导致效率低。</li>
<li>用随机数作为key，所有列表项会重新创建渲染，不会复用。</li>
</ol>
<h2 id="v-for为什么不能跟v-if一起使用"><a href="#v-for为什么不能跟v-if一起使用" class="headerlink" title="v-for为什么不能跟v-if一起使用"></a>v-for为什么不能跟v-if一起使用</h2><p>v-for优先级高于v-if，这意味着 v-if 将分别重复运行于每个 v-for 循环中，效率比较低。<br>推荐将v-if移到父元素</p>
<h2 id="组件中的data为什么是函数而不是对象"><a href="#组件中的data为什么是函数而不是对象" class="headerlink" title="组件中的data为什么是函数而不是对象"></a>组件中的data为什么是函数而不是对象</h2><p>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝。 </p>
<p>组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的。</p>
<h2 id="Vue的数据为什么频繁变化但只会更新一次DOM"><a href="#Vue的数据为什么频繁变化但只会更新一次DOM" class="headerlink" title="Vue的数据为什么频繁变化但只会更新一次DOM"></a>Vue的数据为什么频繁变化但只会更新一次DOM</h2><p>现在有这样的一种情况，mounted的时候test的值会被循环执行++1000次。 每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue实现了一个queue队列，在下一个tick（或者是当前tick的微任务阶段）统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick（或者是当前tick的微任务阶段）的时候调用，大大优化了性能。</p>
<h2 id="Vue-框架怎么实现对象和数组的监听？"><a href="#Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="Vue 框架怎么实现对象和数组的监听？"></a>Vue 框架怎么实现对象和数组的监听？</h2><ul>
<li>通过递归遍历对象，利用 Object.defineProperty() 也能对对象进行监听</li>
<li>通过重写数组的方法， push, pop….实现对数组的监听。</li>
</ul>
<h2 id="v-model-的原理"><a href="#v-model-的原理" class="headerlink" title="v-model 的原理"></a>v-model 的原理</h2><p>v-modal只是一个语法糖，相当于执行了两步：  </p>
<ol>
<li>将组件的value绑定为一个值</li>
<li>组件内部数据的变化，触发input事件更新。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">// 相当于</span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:value</span>=<span class="string">"msg"</span> @<span class="attr">input</span>=<span class="string">"msg=$event.target.value"</span>/&gt;</span></span><br><span class="line">watch: &#123;</span><br><span class="line">    value(val) &#123;</span><br><span class="line">        this.innerValue = val</span><br><span class="line">    &#125;</span><br><span class="line">    innerValue(val) &#123;</span><br><span class="line">        this.emit('input', val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ul>
<li><p><code>&lt;keep-alive&gt;</code> 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染。</p>
</li>
<li><p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。  </p>
</li>
<li><p>它是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。  </p>
</li>
<li><p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。</p>
</li>
</ul>
<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>一般自定义指令解决的问题或者说使用场景是对普通 DOM 元素进行底层操作。</p>
<h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><p><code>Vue.directive(&#39;test&#39;, hookOptions)</code>  </p>
<h3 id="局部自定义指令"><a href="#局部自定义指令" class="headerlink" title="局部自定义指令"></a>局部自定义指令</h3><p>在组件的directives选项中进行声明。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">        bind() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        inserted() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        update() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的hookOptions用来定义指令的行为。有bind, inserted, update, componentUpdated, unbind 共5个hook函数。</p>
<ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。  </li>
<li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。  </li>
<li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。  </li>
<li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。  </li>
<li>unbind：只调用一次，指令与元素解绑时调用。  </li>
</ul>
<h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><p>过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式中。被添加在 JavaScript 表达式的尾部，由“管道”符号指示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(&apos;test&apos;, value =&gt; &#123; ... &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h3><p>定义在组件的filters选项中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">    test() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick()"></a>nextTick()</h2><p>nextTick一般用在，当我们想在更新数据后，获取被更新的DOM进行操作。  </p>
<p>因为数据更新时，并不会立即更新 DOM。如果在更新数据之后的代码执行DOM操作，有可能达不到预想效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.msg = <span class="string">'hello'</span></span><br><span class="line"><span class="comment">// 此时dom还没有更新</span></span><br><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 此时dom已经更新</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.msg.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="路由鉴权"><a href="#路由鉴权" class="headerlink" title="路由鉴权"></a>路由鉴权</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">meta: &#123;</span><br><span class="line">    requireAuth: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">record</span> =&gt;</span> record.meta.requireAuth)) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么不直接用to-mate判断，而要用to-matched来判断："><a href="#为什么不直接用to-mate判断，而要用to-matched来判断：" class="headerlink" title="为什么不直接用to.mate判断，而要用to.matched来判断："></a>为什么不直接用to.mate判断，而要用to.matched来判断：</h3><p>to.matched能够拿到父级的组件的路由对象，用to.matched则只需要给较高一级的路由添加requiresAuth即可，其下的所有子路由不必添加。</p>
<h2 id="路由动态加载与动态删除"><a href="#路由动态加载与动态删除" class="headerlink" title="路由动态加载与动态删除"></a>路由动态加载与动态删除</h2><p>动态添加: router.addRoutes([…])  </p>
<p>动态删除：</p>
<ol>
<li>刷新页面</li>
<li>替换 router.matcher 为一个新的matcher</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建静态的路由表</span></span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'hash'</span>,</span><br><span class="line">  scrollBehavior: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</span><br><span class="line">  isAddDynamicRoutes: <span class="literal">false</span>, <span class="comment">// 是否已经动态添加路由</span></span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> router = createRouter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加路由</span></span><br><span class="line"><span class="keyword">const</span> addDynamicRoute = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> routes = dynamicRoutes() <span class="comment">// 获得动态添加的路由表</span></span><br><span class="line">  router.addRoutes(routes)</span><br><span class="line">  router.options.isAddDynamicRoutes = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置路由，即动态删除添加的路由</span></span><br><span class="line"><span class="keyword">const</span> resetRoute = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = createRouter()</span><br><span class="line">  router.matcher = newRouter.matcher <span class="comment">// reset router</span></span><br><span class="line">  router.options.isAddDynamicRoutes = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vue的运行流程，new-Vue都做了什么"><a href="#Vue的运行流程，new-Vue都做了什么" class="headerlink" title="Vue的运行流程，new Vue都做了什么"></a>Vue的运行流程，new Vue都做了什么</h2><ol>
<li>initLifecycle(vm) 初始化生命周期</li>
<li>initEvents(vm) 初始化事件中心</li>
<li>initRender(vm) 初始化渲染</li>
<li>callHook(vm, ‘beforeCreate’) 触发beforeCreate生命周期</li>
<li>initInjections(vm) 初始化别处注入过来的inject对象</li>
<li>initState(vm) 初始化state， props, computed, watcher</li>
<li>initProvide(vm) 初始化给别处提供的Provide对象</li>
<li>callHook(vm, ‘created’) 触发created生命周期</li>
<li>vm.$mount()   <ol>
<li>compile 将el或者template编译成render方法</li>
<li>render 通过执行 createElement 方法生成虚拟DOM节点</li>
<li>vnode  // create diff patch</li>
<li>patch 将虚拟DOM树插入到真实的DOM中</li>
</ol>
</li>
</ol>
<h2 id="Vue响应式原理-数据绑定原理"><a href="#Vue响应式原理-数据绑定原理" class="headerlink" title="Vue响应式原理(数据绑定原理)"></a>Vue响应式原理(数据绑定原理)</h2><p>Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在set时通知订阅者更新，get的时候收集订阅者。模板编译的时候，生成对应的订阅者，调用这个属性的get，主动去完成这个订阅者收集。所以一共分为4部分：</p>
<ol>
<li><p>对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。调用getter的时候，进行依赖收集，将Observer存起来。调用setter的时候通知更新。每一个对象属性都有自己的任务中心。</p>
</li>
<li><p>模板编译的时候，对模板上的每一个属性，生成对应的订阅者，这样数据变化时，可以通知模板视图的更新。</p>
</li>
<li><p>实现一个任务调度中心：采用 发布-订阅 设计模式，用来收集订阅者 Observer，以及通知Observer去更新。</p>
</li>
<li><p>实现一个Observer类，用来作为订阅者类。订阅者初始化的时候主动调用属性的getter，将自己作为订阅这个属性变化的，完成依赖收集。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = options.data;</span><br><span class="line">    <span class="keyword">this</span>.walkData(<span class="keyword">this</span>.data);</span><br><span class="line">    <span class="keyword">this</span>.compile();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一步</span></span><br><span class="line">  walkData(data) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> val = data[key];</span><br><span class="line">      <span class="keyword">let</span> eventCenter = <span class="keyword">new</span> EventCenter(); <span class="comment">// 每一个属性都有一个任务中心</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">          val = value;</span><br><span class="line">          eventCenter.notify(); <span class="comment">// 通知所有的observer更新</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">get</span>(value) &#123;</span><br><span class="line">          eventCenter.collect(); <span class="comment">// 最开始collect的时候， 因为EventCenter.target是null， 所以并没有依赖，只有编译页面的时候， 才将依赖收集上来</span></span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步</span></span><br><span class="line">  compile() &#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(); <span class="comment">// 指定target 和 调用get，完成依赖收集</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventCenter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = []; <span class="comment">// 存储所有的observer</span></span><br><span class="line">  &#125;</span><br><span class="line">  addObserver(ob) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(ob);</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">ob</span>) =&gt;</span> &#123;</span><br><span class="line">      ob.update();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  collect() &#123;</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (EventCenter.target) &#123; <span class="comment">// 这里是重点，借用静态属性target存储当前的observer实例。</span></span><br><span class="line">      EventCenter.target.addSelf(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventCenter.target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四步</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    EventCenter.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 调用get， 完成依赖收集</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;&#125;</span><br><span class="line">  addSelf(eventCenter) &#123;</span><br><span class="line">    eventCenter.addObserver(<span class="keyword">this</span>); <span class="comment">// 将自己添加到事件调度中心的订阅者队列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vue响应式原理的两大缺陷，解决办法"><a href="#vue响应式原理的两大缺陷，解决办法" class="headerlink" title="vue响应式原理的两大缺陷，解决办法"></a>vue响应式原理的两大缺陷，解决办法</h2><ol>
<li>无法监听到对象属性的动态添加和删除。用this.$set 或者this.$delete解决</li>
<li>无法监听到数组下标和length长度的变化。用 arr.splice 解决</li>
</ol>
<h2 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h2><p>会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。</p>
<ol>
<li>obj  要在其上定义属性的对象。</li>
<li>prop  要定义或修改的属性的名称。</li>
<li><p>descriptor  将被定义或修改的属性描述符。属性描述符有两种主要形式：数据描述符和存取描述符。描述符必须是这两种形式之一，不能同时是两者。</p>
<p> 数据描述符</p>
<ul>
<li>writable<br>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</li>
<li><p>value<br>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p>
<p>存取描述符</p>
</li>
<li>get<br>当访问该属性时，该方法会被执行，默认为 undefined。</li>
<li><p>set<br>当属性值修改时，触发执行该方法，该方法将接受唯一参数，即该属性新的参数值。默认为 undefined  </p>
<p>数据描述符和存取描述符均具有以下可选键值</p>
</li>
<li>configurable<br>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变(也就是可以被重新defineProperty)，同时该属性也能从对应的对象上被删除。默认为 false。</li>
<li>enumerable<br>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</li>
</ul>
</li>
</ol>
<h2 id="Proxy与Object-defineProperty的优劣势对比"><a href="#Proxy与Object-defineProperty的优劣势对比" class="headerlink" title="Proxy与Object.defineProperty的优劣势对比"></a>Proxy与Object.defineProperty的优劣势对比</h2><p>Proxy 的优势如下:</p>
<ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法, 很多是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
</ul>
<p>Object.defineProperty 的优势如下:</p>
<p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</p>
<h2 id="watch实现原理"><a href="#watch实现原理" class="headerlink" title="watch实现原理"></a>watch实现原理</h2><p>initWatch的过程中其实就是实例化new Watcher完成观察者的依赖收集的过程。<br>参考Vue响应式原理。</p>
<h2 id="computed实现原理"><a href="#computed实现原理" class="headerlink" title="computed实现原理"></a>computed实现原理</h2><p>除了依赖收集，他还有个动态计算的过程，只有依赖的数据发生变化，他才重新计算。<br>参考Vue响应式原理。</p>
<h2 id="EventBus的实现原理"><a href="#EventBus的实现原理" class="headerlink" title="EventBus的实现原理"></a>EventBus的实现原理</h2><p>其实就是发布订阅模式的事件调度中心的实现。</p>
<ol>
<li>有一个对象或者Map，来存储事件，以及对应的处理函数。</li>
<li>一个on方法，来监听某事件，然后将对应的处理函数push进去。</li>
<li>一个off方法，来删除某事件的监听。</li>
<li>一个trigger方法， 来触发某事件的处理函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    on(topic, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.map.get(topic)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.map.get(topic).push(callback)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.map.set(topic, [callback])</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    off(topic) &#123;</span><br><span class="line">        <span class="keyword">this</span>.map.delete(topic)</span><br><span class="line">    &#125;</span><br><span class="line">    trigger(topic)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.map.get(topic))&#123;</span><br><span class="line">            <span class="keyword">this</span>.map.get(topic).forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚拟DOM（Virtual-Dom）原理"><a href="#虚拟DOM（Virtual-Dom）原理" class="headerlink" title="虚拟DOM（Virtual Dom）原理"></a>虚拟DOM（Virtual Dom）原理</h2><p>虚拟dom只是一层对真实DOM树的抽象，对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过diff算法得出一些需要修改的最小单位,再更新视图，减少了dom操作，提高了性能。</p>
<p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ol>
<li><p>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；一般虚拟DOM都有以下几个属性。</p>
<ul>
<li>节点名称 tag</li>
<li>节点属性 props 对象</li>
<li>子节点 children 数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text"</span>&gt;hello world!!!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 转化为虚拟dom</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">    tag: 'div',</span></span><br><span class="line"><span class="regexp">    props: &#123;</span></span><br><span class="line"><span class="regexp">        id: 'app'</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    children: [</span></span><br><span class="line"><span class="regexp">        &#123;</span></span><br><span class="line"><span class="regexp">            tag: 'p',</span></span><br><span class="line"><span class="regexp">            props: &#123;</span></span><br><span class="line"><span class="regexp">                className: 'text'</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">            chidren: [</span></span><br><span class="line"><span class="regexp">                'hello world!!!'</span></span><br><span class="line"><span class="regexp">            ]</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    ]</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>diff 算法 — 比较两棵虚拟 DOM 树的差异；</p>
<ul>
<li>比较只会在同层级进行, 不会跨层级比较</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
</ul>
</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ol>
<h2 id="vue-scoped-是怎么实现的"><a href="#vue-scoped-是怎么实现的" class="headerlink" title="vue scoped 是怎么实现的"></a>vue scoped 是怎么实现的</h2><ol>
<li>给HTML的DOM节点加一个不重复data属性(形如：data-v-2311c06a)来表示他的唯一性。</li>
<li>在每句css选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器的哈希特征值（如[data-v-2311c06a]）来私有化样式。</li>
</ol>
<h2 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h2><h3 id="前端路由："><a href="#前端路由：" class="headerlink" title="前端路由："></a>前端路由：</h3><p>路由模块的本质 就是建立起url和页面之间的映射关系，在单页面应用程序中，动态替换DOM内容并同步修改url地址。</p>
<h3 id="hash模式："><a href="#hash模式：" class="headerlink" title="hash模式："></a>hash模式：</h3><p>使用 URL 的 hash 来模拟一个完整的 URL，只改变hash#后的部分。通过监听hashchange事件，监测hash值变化，实现更新页面部分内容。</p>
<h3 id="history模式："><a href="#history模式：" class="headerlink" title="history模式："></a>history模式：</h3><p>利用HTML5 History API, pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求，同时还有popstate事件。</p>
<h3 id="hash模式和history模式的区别"><a href="#hash模式和history模式的区别" class="headerlink" title="hash模式和history模式的区别"></a>hash模式和history模式的区别</h3><ul>
<li>一般使用场景没啥区别，他们俩也都可以使用浏览器的前进后退按钮。</li>
<li>hisotry 模式需要配置服务器， 否则刷新页面可能会导致404</li>
<li>hash 模式带#号，一般不能用来做分享的url，因为有的app里面url是不允许带有#号的</li>
</ul>
<h2 id="vuex-state、getter、mutation、action、module"><a href="#vuex-state、getter、mutation、action、module" class="headerlink" title="vuex state、getter、mutation、action、module"></a>vuex state、getter、mutation、action、module</h2><p>state对象可以包含本应用全部的状态。在组件中通过this.$store.state来访问<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    testState: <span class="string">'this is a state'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getter可以认为是 store 的计算属性。在组件中通过this.$store.getters来访问<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    testGetter: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.testState + <span class="string">' testGetters'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更改 store 中的状态的唯一方法是提交 mutation  </p>
<p>mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">// ES6中属性命名也可以用 []，里面是表达式</span></span><br><span class="line">    [types.TEST_MUTATION_CHANGE_STATE] (state, payload) &#123;</span><br><span class="line">        state.testState = payload.newState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'TEST_MUTATION_CHANGE_STATE'</span>, &#123;</span><br><span class="line">    newState: <span class="string">'this is new state'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态； Action 可以包含任意异步操作。<br>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">testActionChangeState (&#123; commit &#125;, payload) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(types.TEST_MUTATION_CHANGE_STATE, &#123;</span><br><span class="line">            newState: payload.newState</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'testActionChangeState'</span>, &#123;</span><br><span class="line">    newState: <span class="string">'this is new state'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>module可以将store分割成小模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="mapState-mapGetters-mapMutations-mapActions"><a href="#mapState-mapGetters-mapMutations-mapActions" class="headerlink" title="mapState mapGetters mapMutations mapActions"></a>mapState mapGetters mapMutations mapActions</h2><p>mapState 和 mapGetters 可以将state和getter映射成组件中的计算属性<br>mapMutations 和 mapActions 可以映射成组件中的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, mapGetters, mapMutations, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([</span><br><span class="line">        <span class="string">'testState'</span></span><br><span class="line">    ]),</span><br><span class="line"></span><br><span class="line">    ...mapGetters([</span><br><span class="line">        <span class="string">'testGetter'</span></span><br><span class="line">    ])</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">        <span class="string">'TEST_MUTATION_CHANGE_STATE'</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions([</span><br><span class="line">        <span class="string">'testActionChangeState'</span></span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="vue项目优化"><a href="#vue项目优化" class="headerlink" title="vue项目优化"></a>vue项目优化</h2><h3 id="代码层面的优化"><a href="#代码层面的优化" class="headerlink" title="代码层面的优化"></a>代码层面的优化</h3><ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch  区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<h3 id="Webpack-层面的优化"><a href="#Webpack-层面的优化" class="headerlink" title="Webpack 层面的优化"></a>Webpack 层面的优化</h3><ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<h3 id="基础的-Web-技术的优化"><a href="#基础的-Web-技术的优化" class="headerlink" title="基础的 Web 技术的优化"></a>基础的 Web 技术的优化</h3><ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
</div><div class="tags"><a href="/tags/Vue/">Vue</a></div><div class="post-nav"><a class="pre" href="/2022/01/11/1/vue3-vite/">Vue3-Vite</a><a class="next" href="/2022/01/11/1/JavaScript/">JavaScript</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'cXa2hNBumN2DUEHc5sMwqmAR-gzGzoHsz',
  appKey:'k25vMV7ayuuHBhTaLWsiFGXp',
  placeholder:'ヾﾉ≧∀≦)o欢迎你的评论~~~',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://cuiqs.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/八股文/">八股文</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/">学习</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/防火墙/" style="font-size: 15px;">防火墙</a> <a href="/tags/OKR/" style="font-size: 15px;">OKR</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/浏览器/" style="font-size: 15px;">浏览器</a> <a href="/tags/Webkit/" style="font-size: 15px;">Webkit</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/virtualenv/" style="font-size: 15px;">virtualenv</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/ubuntu-nginx/" style="font-size: 15px;">ubuntu nginx</a> <a href="/tags/抓取网页/" style="font-size: 15px;">抓取网页</a> <a href="/tags/webpack4/" style="font-size: 15px;">webpack4</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/Webpack/" style="font-size: 15px;">Webpack</a> <a href="/tags/Vue3-Vite/" style="font-size: 15px;">Vue3-Vite</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/网络与安全/" style="font-size: 15px;">网络与安全</a> <a href="/tags/软性/" style="font-size: 15px;">软性</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/CSS/">CSS</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/HTML/">HTML</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/React/">React</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/Webpack/">Webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/vue3-vite/">Vue3-Vite</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/Vue/">Vue</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/JavaScript/">JavaScript</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/性能优化/">性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/ES6/">ES6</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/浏览器/">浏览器</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">不着急.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>