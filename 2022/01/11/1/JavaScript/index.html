<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="吾心自足，心无外物，时时可死。步步求生，纵横四海，心无挂碍。"><title>JavaScript | 不着急</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript</h1><a id="logo" href="/.">不着急</a><p class="description">吾心自足，心无外物，时时可死。步步求生，纵横四海，心无挂碍。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/yys/"><i class="fa fa-lab"> lab</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript</h1><div class="post-meta">Jan 11, 2022<span> | </span><span class="category"><a href="/categories/八股文/">八股文</a></span></div><a class="disqus-comment-count" href="/2022/01/11/1/JavaScript/#vcomment"><span class="valine-comment-count" data-xid="/2022/01/11/1/JavaScript/"></span><span> 条评论</span></a><div class="post-content"><h2 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h2><ul>
<li>==：比较值，类型不同的时候，先进行类型转换，再比较值；1 == “1”  true  </li>
<li>===：比较类型和值，不做类型转换，类型不同就是不等；1 === “1”  false</li>
</ul>
<h2 id="false，是true还是false，隐式转换"><a href="#false，是true还是false，隐式转换" class="headerlink" title="[] == false，是true还是false，隐式转换"></a>[] == false，是true还是false，隐式转换</h2><p>true。</p>
<ul>
<li>NaN和其他任何类型比较永远返回false。</li>
<li>Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。</li>
<li>String和Number比较，先将String转换为Number类型。</li>
<li>null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。</li>
<li>两个引用类型比较，引用地址不一样，直接false。</li>
<li>原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型。<ul>
<li>引用类型先调用valueOf()，如果是基本类型，直接返回</li>
<li>不是基本类型，再调用toString</li>
<li>String再转Number</li>
</ul>
</li>
</ul>
<h2 id="与或非优先级运算"><a href="#与或非优先级运算" class="headerlink" title="与或非优先级运算"></a>与或非优先级运算</h2><ol>
<li><p>与或非混合时，非&gt;与&gt;或。 </p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> &amp;&amp; !<span class="literal">false</span> || <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> || !<span class="literal">false</span> &amp;&amp; <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&amp;&amp; 和 || 的短路运算</p>
<ul>
<li><p>&amp;&amp;的短路运算：左边能转成false，无条件返回左边式子的值。反之无条件返回右边式子的值</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> &amp;&amp; <span class="number">1</span>; <span class="comment">// 输出false</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="number">1</span>; <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>||的短路运算：若左边能转成true，无条件返回左边式子的值。反之无条件返回右边式子的值</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> || <span class="number">1</span>; <span class="comment">// 输出1</span></span><br><span class="line"><span class="literal">true</span> || <span class="number">1</span>; <span class="comment">// 输出true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="Object-is-value1-value2"><a href="#Object-is-value1-value2" class="headerlink" title="Object.is(value1, value2)"></a>Object.is(value1, value2)</h2><p><code>Object.is()</code>是在ES6中定义的一个新方法，它与‘===’相比，特别针对-0、+0、NaN做了处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span>/<span class="number">0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="6种基本数据类型和3种引用类型"><a href="#6种基本数据类型和3种引用类型" class="headerlink" title="6种基本数据类型和3种引用类型"></a>6种基本数据类型和3种引用类型</h2><ul>
<li>number, boolean, string, null, undefined, Symbol  </li>
<li>Object, Array, Function</li>
</ul>
<h2 id="javascript自带的数据结构"><a href="#javascript自带的数据结构" class="headerlink" title="javascript自带的数据结构"></a>javascript自带的数据结构</h2><ul>
<li>Object, Array, Set, Map, WeakSet, WeakMap</li>
</ul>
<h2 id="null和undefined有什么区别"><a href="#null和undefined有什么区别" class="headerlink" title="null和undefined有什么区别"></a>null和undefined有什么区别</h2><ul>
<li>null表示空对象  </li>
<li>undefined表示未初始化的变量</li>
</ul>
<h2 id="number的最大-小值，最大-小安全整数，位数"><a href="#number的最大-小值，最大-小安全整数，位数" class="headerlink" title="number的最大/小值，最大/小安全整数，位数"></a>number的最大/小值，最大/小安全整数，位数</h2><p>Number.MAX_VALUE，Number.MIN_VALUE，Number.MAX_SAFE_INTEGER，Number.MIN_SAFE_INTEGER</p>
<p>所有 JavaScript 数字均为 64 位。其中 0 到 51 存储数字（占52位），52 到 62 存储指数（占11位），63 位存储符号。</p>
<h2 id="Object-和-Map-有什么区别"><a href="#Object-和-Map-有什么区别" class="headerlink" title="Object 和 Map 有什么区别"></a>Object 和 Map 有什么区别</h2><ul>
<li>Object 键（key）的类型只能是字符串，数字或者 Symbol；而 Map 可以是任何类型。</li>
<li>Map 中的元素会保持其插入时的顺序；而 Object 则不会完全保持插入时的顺序。</li>
<li>Object的key顺序：<ol>
<li>key是整数或者整数类型的字符串，那么会按照从小到大的排序。</li>
<li>其它数据类型，控制台展示的时候，按照ASC码升序排序，如果用Object.keys()获取，按照实际创建顺序排序。</li>
</ol>
</li>
<li>Map 是可迭代对象，所以其中的键值对是可以通过 for of 循环或 .foreach() 方法来迭代的；而普通的对象键值对则默认是不可迭代的，只能通过 for in 循环来访问。</li>
</ul>
<h2 id="一个对象作为key，会自动转成-object-Object-，第二个O大写"><a href="#一个对象作为key，会自动转成-object-Object-，第二个O大写" class="headerlink" title="一个对象作为key，会自动转成[object,Object]，第二个O大写"></a>一个对象作为key，会自动转成[object,Object]，第二个O大写</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">"Sam"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">name</span>: <span class="string">"Tom"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[a] = <span class="number">1</span>;</span><br><span class="line">o[b] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o[a]); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="function-length可以获取函数的参数个数"><a href="#function-length可以获取函数的参数个数" class="headerlink" title="function.length可以获取函数的参数个数"></a>function.length可以获取函数的参数个数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c</span><br><span class="line">sum.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>柯里化是编程语言中的一个通用的概念（不只是Js，其他很多语言也有柯里化），是指把接收多个参数的函数变换成接收单一参数的函数，嵌套返回直到所有参数都被使用并返回最终结果。</p>
<p>更简单地说，柯里化是一个函数变换的过程，是将函数从调用方式：f(a,b,c)变换成调用方式：f(a)(b)(c)的过程。</p>
<p>柯里化不会调用函数，它只是对函数进行转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c</span><br><span class="line"><span class="keyword">const</span> fn = curry(sum);</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">fn(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现柯里化函数curry</span></span><br><span class="line"><span class="keyword">const</span> curry = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        思路解析：</span></span><br><span class="line"><span class="comment">        1. 接受一个原函数，返回一个柯里化后的函数</span></span><br><span class="line"><span class="comment">        2. 如果柯里化后的函数接受的参数个数大于等于原函数的参数个数，直接调用原函数，返回结果</span></span><br><span class="line"><span class="comment">        3. 否则的话，说明参数还未接受完毕，返回一个函数，继续接受新的参数，旧参数+新的参数 去递归</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> nest = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn(...args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...restArgs</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nest(...[...args, ...restArgs])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型和引用类型存储在哪里"><a href="#基本数据类型和引用类型存储在哪里" class="headerlink" title="基本数据类型和引用类型存储在哪里"></a>基本数据类型和引用类型存储在哪里</h2><ul>
<li>基本数据类型：变量标识符和变量的值存放于栈内存。占用固定大小的空间。  </li>
<li>引用类型：变量标识符和指向堆内存中该对象的指针存放于栈，具体的对象存放于堆。</li>
</ul>
<h2 id="一个string，他不定长，放在栈中是怎么处理的？"><a href="#一个string，他不定长，放在栈中是怎么处理的？" class="headerlink" title="一个string，他不定长，放在栈中是怎么处理的？"></a>一个string，他不定长，放在栈中是怎么处理的？</h2><p>基本数据类型不一定是直接存在栈中的。</p>
<ul>
<li>字符串： 存在堆里，栈中为引用地址，如果存在相同字符串，则引用地址相同。</li>
<li>数字： 小整数（-2³¹ 到 2³¹-1（2³¹≈2*10⁹）的整数）存在栈中，其他类型存在堆中，如小数。</li>
<li>其他类型：引擎初始化时分配唯一地址，栈中的变量存的是唯一的引用。</li>
</ul>
<h2 id="函数的参数是按照什么方式传递的"><a href="#函数的参数是按照什么方式传递的" class="headerlink" title="函数的参数是按照什么方式传递的"></a>函数的参数是按照什么方式传递的</h2><h3 id="按值传递-vs-按引用传递"><a href="#按值传递-vs-按引用传递" class="headerlink" title="按值传递 vs 按引用传递"></a>按值传递 vs 按引用传递</h3><ul>
<li>按值传递：实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值。按值传递的意思就是形参是实参的复制。    </li>
<li>按引用传递：就是传递对象的引用，实参和形参是完全一样的，函数内部对形参的任何改变都会影响实际参数。函数的形参接收实参的隐式引用，而不再是副本。  </li>
</ul>
<h3 id="首先理解复制变量："><a href="#首先理解复制变量：" class="headerlink" title="首先理解复制变量："></a>首先理解复制变量：</h3><ul>
<li>基本数据类型：将原始值副本赋值给新的变量，所以两个变量是完全独立的，只不过value相同。  </li>
<li>复杂类型：将指针（内存地址）赋值给新的变量，所以两个变量保存的内存地址一致，也就是指向的具体的对象一致。任何一个改变都会影响另一个。</li>
</ul>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>传递参数就是变量复制的过程，将实参的值赋值给形参。<br>其实都是<b>按值传递</b>的。只不过有的值是基本类型，有的值是内存地址  </p>
<h3 id="证明不是按引用传递"><a href="#证明不是按引用传递" class="headerlink" title="证明不是按引用传递"></a>证明不是按引用传递</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"MJ"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">'test'</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"EP"</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// 输出test</span></span><br></pre></td></tr></table></figure>
<p>说明形参obj和实参person是两个东西，只不过值相同，都是同一个内存地址，都指向了同一个对象。<br>如果是按引用传递，那他两个应该是同一个东西，修改obj=new Object()之后，person也应该是这个新的object。</p>
<h2 id="js内置对象"><a href="#js内置对象" class="headerlink" title="js内置对象"></a>js内置对象</h2><p>基本对象：</p>
<ol>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Number </li>
<li>String</li>
<li>Boolean</li>
</ol>
<p>其他对象：</p>
<ol>
<li>Error</li>
<li>Date</li>
<li>Math</li>
<li>RegExp</li>
<li>JSON</li>
</ol>
<p>ES6新增对象：</p>
<ol>
<li>Symbol</li>
<li>Set &amp; WeakSet</li>
<li>Map &amp; WeakMap</li>
<li>Proxy</li>
<li>Reflect</li>
<li>Promise</li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>一个函数包含另一个函数，并且被包含的函数使用了父函数中的变量。内部函数即为闭包。<br>即有权访问另一个函数作用域内变量的函数都是闭包。 </p>
<ul>
<li><p>闭包的特性：<br>  内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后  </p>
</li>
<li><p>闭包的作用：  </p>
<ol>
<li>使其他函数可以访问某函数内部的变量</li>
<li>让函数内部的变量一直隐藏/保存在内存中（但是这样会导致内存泄漏，所以在退出函数之前，应将不使用的局部变量设为null）</li>
<li>实现私有变量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'cxk'</span>;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cxk = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(cxk.getName()) <span class="comment">//cxk</span></span><br><span class="line">cxk.setName(<span class="string">'jntm'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(cxk.getName()) <span class="comment">//jntm</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">//name is not defined</span></span><br><span class="line"><span class="comment">// 函数体内的var name = 'cxk'只有getName和setName两个函数可以访问，外部无法访问，相对于将变量私有化</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="立即执行函数-IIFE"><a href="#立即执行函数-IIFE" class="headerlink" title="立即执行函数(IIFE)"></a>立即执行函数(IIFE)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">&#125;)(i)</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">&#125;(i))</span><br></pre></td></tr></table></figure>
<p>作用：  </p>
<ol>
<li>创建一个独立的作用域。这个作用域里面的变量，外面访问不到（即避免「变量污染」）</li>
<li>如果需要访问这里面的方法，可以挂载在window上，或者return给外面。以此模拟模块。</li>
</ol>
<h2 id="js运行机制"><a href="#js运行机制" class="headerlink" title="js运行机制"></a>js运行机制</h2><p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。</p>
<h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><ul>
<li>词法分析（Tokenizing/Lexing）</li>
<li>语法分析（Parsing）</li>
<li>预编译（解释）</li>
</ul>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>将JavaScript代码分为一块块的可执行代码块进行执行，在代码块执行前会创建执行上下文，目前有三类代码块：  </p>
<ul>
<li>全局代码块（Global code）</li>
<li>函数代码块（Function code）</li>
<li>eval代码块（Eval code）  </li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>根据这三类代码快创建三种执行上下文</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval执行上下文</li>
</ul>
<p>执行上下文也分为两个阶段(ES6规范)：</p>
<ol>
<li>创建阶段<ul>
<li>决定 this 的指向</li>
<li>创建词法环境(LexicalEnvironment) (也就是作用域) <ol>
<li>函数声明</li>
<li>变量声明</li>
<li>确立作用域和作用域链</li>
</ol>
</li>
<li>创建变量环境(VariableEnvironment)<ol>
<li>var类型的变量声明（变量提升）</li>
</ol>
</li>
</ul>
</li>
<li>执行阶段  <ul>
<li>变量赋值</li>
<li>函数执行</li>
</ul>
</li>
</ol>
<h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><p>代码在运行过程中，会有一个叫做调用栈(call stack)的概念。调用栈是一种栈结构,它用来存储计算机程序执行时候其活跃子程序的信息（即执行上下文）。 </p>
<p>在执行阶段，先将全局执行上下文放入函数调用栈栈底，然后执行函数，并将函数执行上下文放入栈。  </p>
<p>处于栈顶的上下文执行完毕之后，就会自动出栈。函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。</p>
<h3 id="作用域，作用域链"><a href="#作用域，作用域链" class="headerlink" title="作用域，作用域链"></a>作用域，作用域链</h3><p>在ES6规范中，作用域更官方的叫法是词法环境（Lexical Environments），它由两部分组成：  </p>
<ul>
<li>记录作用域内变量信息（我们假设let变量，const常量，函数等统称为变量）和代码结构信息的东西，称之为 Environment Record。</li>
<li>一个引用 <code>__outer__</code>，这个引用指向当前作用域的父作用域。全局作用域的 <code>__outer__</code> 为 null。</li>
</ul>
<p>可执行上下文中的词法环境中含有外部词法环境的引用，我们可以通过这个引用获取外部词法环境的变量、声明等，这些引用串联起来一直指向全局的词法环境，因此形成了作用域链。</p>
<h3 id="变量查找（ResolveBinding）："><a href="#变量查找（ResolveBinding）：" class="headerlink" title="变量查找（ResolveBinding）："></a>变量查找（ResolveBinding）：</h3><p>先从当前的执行上下文中找保存的作用域，查看当前作用域里面的 Environment Record 是否有此变量的信息，如果找到了，则返回当前作用域内的这个变量。如果没有查找到，则顺着 <code>__outer__</code> 到父作用域里面的 Environment Record 查找，以此递归。</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>在执行上下文的创建阶段，会先声明var类型的变量，但不进行赋值，执行阶段才去赋值。<br>所以在后面的代码中可以先使用这个变量，但是他是undefined</p>
<h3 id="var变量声明-和-函数声明都会变量提升"><a href="#var变量声明-和-函数声明都会变量提升" class="headerlink" title="var变量声明 和 函数声明都会变量提升"></a>var变量声明 和 函数声明都会变量提升</h3><ol>
<li>var变量声明 和 函数声明都会变量提升</li>
<li>函数声明是整体提升，优先级高于var声明，且直接赋值</li>
<li>具体的执行是什么取决于赋值是什么。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log() <span class="comment">// 输出 1</span></span><br><span class="line"><span class="comment">// function log 先提升， var log 再提升，function log 会直接给log 赋值。 var log = function 再赋值，所以最后log是consolo.log(1)的</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>简单来说，谁调用这个函数，这个函数中的this就指向谁</p>
<ul>
<li><code>fn()</code>  fn单独调用，this指向window</li>
<li><code>obj1.obj2.fn();</code> this指向obj2</li>
<li><code>var bar = obj.fn; bar();</code> this指向window</li>
<li>call()、apply()、bind()，指向新的这个对象</li>
<li>箭头函数中this指向所在上下文</li>
</ul>
<p>从原理上来说，在创建可执行上下文的时候，根据代码的执行条件，来判断分别进行默认绑定、隐式绑定、显示绑定等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">10</span>,</span><br><span class="line">    bar() &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.bar() <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">var</span> foo = obj.bar;</span><br><span class="line">foo() <span class="comment">// 0</span></span><br><span class="line">obj.bar.call(<span class="built_in">window</span>) <span class="comment">// 0</span></span><br><span class="line">obj.bar.call(obj) <span class="comment">// 10</span></span><br><span class="line">foo.call(obj) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p>
<h2 id="v8执行原理"><a href="#v8执行原理" class="headerlink" title="v8执行原理"></a>v8执行原理</h2><ol>
<li>初始化堆栈空间，全局上下文，全局作用域，事件循环系统。</li>
<li>输入全局的js代码，解析器(Parser)通过词法分析，生成tokens，语法分析根据tokens生成AST抽象语法树。</li>
<li>解释器(Ignition) 会将 AST 转换为字节码，一边解释一边执行。（解释执行）</li>
<li>在解释执行字节码的过程中，如果发现一段代码被多次重复执行，就会将其标记为热点（Hot）代码。V8 会将这段热点代码丢给优化编译器 TurboFan 编译为二进制代码。如果下次再执行时，就会直接执行二进制代码，提高执行速度。（编译执行）</li>
<li>如果遇到普通函数，只会对其进行预解析(Pre-Parser)，验证函数的语法是否有效、解析函数声明以及确定函数作用域，并不会生成 AST，当函数被调用时，才会对其完全解析。</li>
</ol>
<p><img src="https://cdn.lishuxue.site/blog/image/面试/v8.png" alt="v8"></p>
<h3 id="js-到底是解释型还是编译型语言？"><a href="#js-到底是解释型还是编译型语言？" class="headerlink" title="js 到底是解释型还是编译型语言？"></a>js 到底是解释型还是编译型语言？</h3><p>V8 同时采用了解释执行和编译执行这两种方式，这种混合使用的方式称为 JIT (即时编译)。  </p>
<h2 id="什么是作用域链，什么是原型链，它们的区别"><a href="#什么是作用域链，什么是原型链，它们的区别" class="headerlink" title="什么是作用域链，什么是原型链，它们的区别"></a>什么是作用域链，什么是原型链，它们的区别</h2><ul>
<li>作用域是针对变量的，先在自己的作用域上下文寻找， 找不到再去父级作用域寻找，形成作用域链。</li>
<li>原型链是针对对象属性或者方法的， 当我们从一个对象上寻找某个属性或者方法时， 先在本身寻找， 没有的话就去父类的原型上找。父类原型找不到，再去父类的父类的原型找。形成原型链。</li>
</ul>
<h2 id="原型，原型链，构造函数"><a href="#原型，原型链，构造函数" class="headerlink" title="原型，原型链，构造函数"></a>原型，原型链，构造函数</h2><p><b>原型：</b>即prototype属性，只有函数才有，用来存放所有实例对象需要共享的属性和方法。那些不需要共享的属性和方法，就放在构造函数里面。<br><b>构造函数：</b>用来创建实例。通过new关键字可以创建实例。命名通常首字母大写。<br><b>原型链：</b>即<strong>proto</strong>属性，任何对象都有这个属性。  </p>
<p>结论：</p>
<ol>
<li>对象的<strong>proto</strong>属性指向父类的prototype属性，没有父类则指向Object.prototype</li>
<li>类的<strong>proto</strong>属性指向父类，如果没有父类指向Function.prototype。ES5中用function创建的类，<strong>proto</strong>都指向Function.prototype。  </li>
</ol>
<hr>
<ol start="3">
<li>对象的.constructor指向本类</li>
<li>类的prototype.constructor指向本类</li>
<li>类的.constructor指向Function</li>
</ol>
<hr>
<ol start="6">
<li>类的prototype是父类的实例， 所以instanceof 父类是true，没有父类时instanceof Object是true</li>
</ol>
<p>5.6 也证明在自己写继承的时候， 要些这两行代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure></p>
<p>当我们访问一个对象的属性或方法时，如果这个对象内部不存在这个属性，那么他就会去他的<strong>proto</strong>里找这个属性，也就是去父类的protorype上找，父类的prototype上如果没有，这个prototype又会去找他的<strong>proto</strong>，这个<strong>proto</strong>又会有自己的<strong>proto</strong>，于是就这样 一直找下去，也就是我们平时所说的原型链的概念。</p>
<p>一张图总结：主要是每个部分都要明白 <strong>proto</strong> 和 constructor的指向<br><img src="https://cdn.lishuxue.site/blog/image/面试/proto3.png" alt="proto"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandPa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'爷爷'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isPerson() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是一个:'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandPa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'爸爸'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'儿子'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ss = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先看构造函数.constructor，构造函数一定是指向某一个函数的</span></span><br><span class="line"><span class="built_in">console</span>.log(ss.constructor === Son) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Son.constructor === <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.constructor === <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.constructor === <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.constructor === <span class="built_in">Function</span>) <span class="comment">// true 函数的构造还是函数</span></span><br><span class="line"><span class="comment">// 再看原型的构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.prototype.constructor === Son) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype.constructor === Father) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.prototype.constructor === GrandPa) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再看__proto__属性</span></span><br><span class="line"><span class="built_in">console</span>.log(ss.__proto__ === Son.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.__proto__ === Father) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.__proto__ === GrandPa) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Son.prototype.__proto__ === Father.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype.__proto__ === GrandPa.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再看原型.prototype，只有函数才有原型对象</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.prototype <span class="keyword">instanceof</span> Father) <span class="comment">// true   Son的原型是Father类的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype <span class="keyword">instanceof</span> GrandPa) <span class="comment">// true  Father的原型是GrandPa类的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true  GrandPa的原型是Object的实例</span></span><br></pre></td></tr></table></figure>
<h2 id="ES5继承"><a href="#ES5继承" class="headerlink" title="ES5继承"></a>ES5继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合继承</span></span><br><span class="line"><span class="keyword">var</span> GrandPa = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'爷爷'</span>;</span><br><span class="line">&#125;</span><br><span class="line">GrandPa.prototype.isPerson = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是一个:'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Father = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    GrandPa.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'爸爸'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype = <span class="keyword">new</span> GrandPa();</span><br><span class="line">Father.prototype.constructor = Father;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Son = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'儿子'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ss = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先看构造函数.constructor，构造函数一定是指向某一个函数的</span></span><br><span class="line"><span class="built_in">console</span>.log(ss.constructor === Son) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Son.constructor === <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.constructor === <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.constructor === <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.constructor === <span class="built_in">Function</span>) <span class="comment">// true 函数的构造还是函数</span></span><br><span class="line"><span class="comment">// 再看原型的构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.prototype.constructor === Son) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype.constructor === Father) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.prototype.constructor === GrandPa) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再看__proto__属性</span></span><br><span class="line"><span class="built_in">console</span>.log(ss.__proto__ === Son.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true 这里跟class形式不一样</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">//true 这里跟class形式不一样</span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Son.prototype.__proto__ === Father.prototype) <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype.__proto__ === GrandPa.prototype) <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再看原型.prototype，只有函数才有原型对象</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.prototype <span class="keyword">instanceof</span> Father) <span class="comment">// true   Son的原型是Father类的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype <span class="keyword">instanceof</span> GrandPa) <span class="comment">// true  Father的原型是GrandPa类的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(GrandPa.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true  GrandPa的原型是Object的实例</span></span><br></pre></td></tr></table></figure>
<h2 id="new-操作符做了什么？怎么模拟new-？"><a href="#new-操作符做了什么？怎么模拟new-？" class="headerlink" title="new 操作符做了什么？怎么模拟new ？"></a>new 操作符做了什么？怎么模拟new ？</h2><ol>
<li>创建了一个空对象<br> <code>var obj = {}</code></li>
<li>将对象的<strong>proto</strong>指向函数的prototype<br> <code>obj.__proto__ = Constructor.prototype</code></li>
<li>将函数的this绑定到这个空对象上<br> <code>var result = Constructor.apply(obj, arguments)</code></li>
<li>判断构造函数的返回值类型，如果没有返回值或者返回值是值类型，返回obj这个新创建的实例（相当于this）。如果返回值时是引用类型比如return {x: ‘a’}，就返回这个引用类型的对象。<br> <code>return result instanceof Object ? result : obj</code></li>
</ol>
<p><b>模拟实现new</b><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params">Constructor, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = Constructor.prototype; <span class="comment">// 或者Object.setPrototypeOf(obj, Constructor.prototype)</span></span><br><span class="line">    <span class="keyword">var</span> result = Constructor.apply(obj, args);</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="箭头函数可以作为构造函数吗？"><a href="#箭头函数可以作为构造函数吗？" class="headerlink" title="箭头函数可以作为构造函数吗？"></a>箭头函数可以作为构造函数吗？</h2><p>不可以。  </p>
<p>普通函数在运行时才会确定 this 的指向。箭头函数则是在函数定义的时候就确定了 this 的指向，此时的 this 指向外层的作用域。所以不可以用来做构造函数，因为如果做构造函数，生成的实例的this不是指向实例，而是指向箭头函数的上下文，这是不对的。</p>
<h2 id="obj-hasOwnProperty-prop"><a href="#obj-hasOwnProperty-prop" class="headerlink" title="obj.hasOwnProperty(prop)"></a>obj.hasOwnProperty(prop)</h2><p>hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性，忽略那些从原型链上继承到的属性。</p>
<h2 id="typeof-instanceof-Object-prototype-toString-call"><a href="#typeof-instanceof-Object-prototype-toString-call" class="headerlink" title="typeof, instanceof, Object.prototype.toString.call()"></a>typeof, instanceof, Object.prototype.toString.call()</h2><ul>
<li><p>typeof 可以用于判断基本数据类型和函数，判断不出来null对象数组和实例。输出的是小写的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>  <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>  <span class="comment">//"boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">typeof</span> s <span class="comment">// "symbol"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span> <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Array</span> <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Function</span> <span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> []  <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)  <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.toString.call()，可以精确判断所有类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)   <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'1'</span>) <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])  <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)  <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Function</span>) <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Array</span>) <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Object</span>) <span class="comment">// "[object Function]"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。即判断某个对象是否是某个构造函数的实例。所以主要是用来检测对象和数组，无法准确判断Function 和基本数据类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d/</span> <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模拟实现instanceof"><a href="#模拟实现instanceof" class="headerlink" title="模拟实现instanceof"></a>模拟实现instanceof</h2><p>instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。即判断，</p>
<ul>
<li><code>实例.__proto__ === 构造函数.prototype</code> 或者 </li>
<li><code>实例.__proto__.__proto__ === 构造函数.prototype</code>，递归。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myinstanceof</span>(<span class="params">instance, func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = instance.__proto__;</span><br><span class="line">    <span class="keyword">let</span> right = func.prototype;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left === <span class="literal">null</span>) &#123; <span class="comment">// 找到最顶层，原型链的最顶层是null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(left === right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left = left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h2><p>会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。</p>
<ol>
<li>obj  要在其上定义属性的对象。</li>
<li>prop  要定义或修改的属性的名称。</li>
<li><p>descriptor  将被定义或修改的属性描述符。属性描述符有两种主要形式：数据描述符和存取描述符。描述符必须是这两种形式之一，不能同时是两者。</p>
<p> 数据描述符</p>
<ul>
<li>writable<br>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</li>
<li><p>value<br>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p>
<p>存取描述符</p>
</li>
<li>get<br>当访问该属性时，该方法会被执行，默认为 undefined。</li>
<li><p>set<br>当属性值修改时，触发执行该方法，该方法将接受唯一参数，即该属性新的参数值。默认为 undefined  </p>
<p>数据描述符和存取描述符均具有以下可选键值</p>
</li>
<li>configurable<br>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变(也就是可以被重新defineProperty)，同时该属性也能从对应的对象上被删除。默认为 false。</li>
<li>enumerable<br>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</li>
</ul>
</li>
</ol>
<h2 id="call，apply，bind区别"><a href="#call，apply，bind区别" class="headerlink" title="call，apply，bind区别"></a>call，apply，bind区别</h2><p>用法：  </p>
<ul>
<li>call方法第一个参数是函数运行时this指向的对象，后面跟多个参数。返回值取决于原始函数的返回值。</li>
<li>apply方法第一个参数也是函数运行时this指向的对象，后面跟参数数组。返回值取决于原始函数的返回值。</li>
<li>bind方法返回值是一个新的函数，这个新的函数被调用时，this指向bind的第一个参数。bind方法后面也可以接收多个参数传递给原始函数。  </li>
</ul>
<p>区别：  </p>
<ul>
<li>第一个参数都是 要绑定的this指向.</li>
<li>apply的第二个参数是一个参数数组,call和bind的第二个及之后的参数作为函数实参按顺序传入。</li>
<li>bind不会立即调用,其他两个会立即调用。</li>
</ul>
<h2 id="模拟实现call-apply-bind"><a href="#模拟实现call-apply-bind" class="headerlink" title="模拟实现call, apply, bind"></a>模拟实现call, apply, bind</h2><p><b>模拟实现call</b><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = context || <span class="built_in">window</span>; <span class="comment">// 如果没有传参，则指向window</span></span><br><span class="line">    <span class="comment">// ctx.func只是一个名字，可以随便取。this是被调用的函数，因为函数调用call方法，call里面的this就指向那个函数。所以ctx.func就是那个函数。</span></span><br><span class="line">    ctx.func = <span class="keyword">this</span>; </span><br><span class="line">    <span class="keyword">const</span> result = ctx.func(...args); <span class="comment">// 调用该方法并传入参数，此时该方法的this指向ctx</span></span><br><span class="line">    <span class="keyword">delete</span> ctx.func; <span class="comment">// 删除该方法，不然会在传入的对象上添加这个方法。</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回返回值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>模拟实现apply</b><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span>(<span class="params">context, arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = context || <span class="built_in">window</span>;</span><br><span class="line">    ctx.func = <span class="keyword">this</span>; </span><br><span class="line">    <span class="keyword">const</span> result = ctx.func(...arr); <span class="comment">// 跟call唯一的区别是参数不一样</span></span><br><span class="line">    <span class="keyword">delete</span> ctx.func;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>模拟实现bind</b><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = context || <span class="built_in">window</span>;</span><br><span class="line">    ctx.func = <span class="keyword">this</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 跟call的区别是不立即执行，而是返回一个函数。</span></span><br><span class="line">        <span class="keyword">const</span> result = ctx.func(...args);</span><br><span class="line">        <span class="keyword">delete</span> ctx.func;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="深拷贝，浅拷贝，Object-assign-、ES6的扩展运算符"><a href="#深拷贝，浅拷贝，Object-assign-、ES6的扩展运算符" class="headerlink" title="深拷贝，浅拷贝，Object.assign()、ES6的扩展运算符"></a>深拷贝，浅拷贝，Object.assign()、ES6的扩展运算符</h2><p>浅拷贝只是拷贝了指向对象的指针。<br>深拷贝则是完全拷贝了整个值，创建了一个新的和原对象值一样的对象。  </p>
<ul>
<li>浅拷贝 直接赋值</li>
<li>深拷贝用_.deepclone、JSON.parse(JSON.stringify(obj))  </li>
</ul>
<p>扩展运算符和Object.assign()都是只复制最外面一层，所以根属性是深拷贝，里面的对象依然是浅拷贝</p>
<h2 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    a: &#123;<span class="attr">b</span>: <span class="string">'b'</span>&#125;,</span><br><span class="line">    c: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    d: [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">    e: <span class="literal">undefined</span>,</span><br><span class="line">    f: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">a.g = a;</span><br><span class="line">a.h = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<ol>
<li><p>简易版： JSON.parse(JSON.stringify(obj));</p>
<ul>
<li>无法解决循环引用问题，会报错。 比如上面的 a.g = a.</li>
<li>无法复制值为undefined的</li>
<li>无法复制函数</li>
<li>无法复制一些特殊的对象，如 RegExp, Date, Set, Map等</li>
</ul>
</li>
<li><p>面试版：</p>
<ul>
<li>第一层如果是对象，循环每一个key，判断每一项<ul>
<li>判断是对象，如果循环引用，返回本身。否则递归调用自身。</li>
<li>判断是数组，遍历数组的每一项，如果是对象，递归调用自身，否则直接返回</li>
<li>判断是函数，重新生成函数</li>
<li>值类型直接复制</li>
</ul>
</li>
<li>第一层如果是数组，递归每一个元素。</li>
<li><p>第一层如果是值类型，直接复制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newobj;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Object]'</span>) &#123; <span class="comment">// 先判断目标类型</span></span><br><span class="line">        newobj = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">let</span> value = obj[key];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object Object]'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value === obj) &#123; <span class="comment">// 循环引用</span></span><br><span class="line">                    newobj[key] = obj;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    newobj[key] = deepClone(value); <span class="comment">// 递归本身</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">                newobj[key] = value.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> deepClone(item); <span class="comment">// 递归数组元素</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object Function]'</span>) &#123;</span><br><span class="line">                newobj[key] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> value.call(<span class="keyword">this</span>, ...arguments) &#125; <span class="comment">// 重新构建函数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newobj[key] = value;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">        newobj = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; obj.length; i++) &#123;</span><br><span class="line">            newobj.push(deepClone(obj[i])) <span class="comment">// 递归数组的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newobj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="节流（throttle），防抖（debounce）"><a href="#节流（throttle），防抖（debounce）" class="headerlink" title="节流（throttle），防抖（debounce）"></a>节流（throttle），防抖（debounce）</h2><ul>
<li>节流：频繁操作的时候，如果超过了设定的时间，就执行一次处理函数。周期性的执行。节流会稀释函数的执行频率。</li>
<li>防抖：频繁操作的时候，如果两次的间隔时间超过了设定的时间，就执行一次处理函数，如果时间没到的时候，就把timer清除。只执行最后一次。需要一个定时器。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>
</ul>
<h3 id="实现节流"><a href="#实现节流" class="headerlink" title="实现节流"></a>实现节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> currentTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (currentTime - startTime &gt;= delay) &#123; <span class="comment">// 靠两次运行的时间戳对比</span></span><br><span class="line">            method.apply(context, args);</span><br><span class="line">            startTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<h3 id="实现防抖"><a href="#实现防抖" class="headerlink" title="实现防抖"></a>实现防抖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 靠setTimout等待一定的时间执行</span></span><br><span class="line">            method.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<h2 id="JS-异步解决方案的发展历程以及优缺点"><a href="#JS-异步解决方案的发展历程以及优缺点" class="headerlink" title="JS 异步解决方案的发展历程以及优缺点"></a>JS 异步解决方案的发展历程以及优缺点</h2><ul>
<li><p>回调函数<br>  缺点：回调地狱，不能用 try catch 捕获错误，不能 return</p>
</li>
<li><p>Promise<br>  优点：解决了回调地狱的问题<br>  缺点：  </p>
<ol>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
<li>Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。</li>
</ol>
</li>
<li><p>Generator<br>  缺点： 使用复杂，需要配合co库</p>
</li>
<li><p>async/await<br>  优点：  </p>
<ol>
<li>同步的写法</li>
<li>可以try catch</li>
<li>没有then的链式调用</li>
<li>错误堆栈信息友好</li>
<li><p>方便调试  </p>
<p>缺点：<br>用async/await需要注意的是，如果里面有多个Promise，需要注意他们是否有依赖，没有依赖的话用await Promise.all([…])</p>
</li>
</ol>
</li>
</ul>
<h2 id="map、forEach、for-in、for-of、Object-keys"><a href="#map、forEach、for-in、for-of、Object-keys" class="headerlink" title="map、forEach、for in、for of、Object.keys"></a>map、forEach、for in、for of、Object.keys</h2><ul>
<li>for in 遍历对象的key，因为key排序的问题，for-in语句无法保证遍历顺序。<br>  <code>for (var prop in obj) { ... }</code></li>
<li>for of ES6引入，用来遍历任何有Iterator接口的数据结构，如数组, Set, Map, String, Arguments等<br>  <code>for (var value of arr) { ... }</code></li>
<li>forEach 遍历数组，不影响原数组<br>  <code>arr.forEach((value, index, arr) =&gt; { ... })</code></li>
<li>map 遍历数组，并返回一个新的数组，新数组元素为原来的数组的每个元素调用func的结果，不影响原数组<br>  <code>arr.map((value, index, arr) =&gt; { return ... })</code></li>
<li>Object.keys也是循环对象的key，返回一个数组</li>
</ul>
<h2 id="js-跳出循环，break-continue-return"><a href="#js-跳出循环，break-continue-return" class="headerlink" title="js 跳出循环，break, continue, return"></a>js 跳出循环，break, continue, return</h2><ol>
<li><p>for 循环，for of循环，while循环，for in循环。都是break跳出循环，continue下一次循环</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i===<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(i===<span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i===<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(i===<span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; arr.length)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>(i===<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(i===<span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>:<span class="string">'a'</span>,<span class="attr">b</span>:<span class="string">'b'</span>,<span class="attr">c</span>:<span class="string">'c'</span>,<span class="attr">d</span>:<span class="string">'d'</span>,<span class="attr">e</span>:<span class="string">'e'</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">'a'</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">'e'</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>map, forEach等循环，不能跳出循环，如果想跳出，只能主动抛出一个异常。throw new Error()</p>
</li>
<li><p>return 一般用来作为函数的返回值，不能单独用在循环中。</p>
<h2 id="前端存储方式"><a href="#前端存储方式" class="headerlink" title="前端存储方式"></a>前端存储方式</h2></li>
<li><p>cookie<br> cookie 中主要存储sessionid，过期时间，域名，路径等。会在发送请求的时候自动携带。为了维持服务器的状态。大小只有4k。</p>
</li>
<li><p>localStorage<br> localStorage 通过key-value存储一些值，大小为5兆，会永久存储在客户端。</p>
</li>
<li><p>sessionStorage<br> sessionStorage 跟localStorage相似，会话级别，关闭页面就会消失。</p>
</li>
<li><p>IndexDB<br> 前端的非关系型数据库，用于在客户端存储大量的数据.</p>
</li>
</ol>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><ol>
<li><code>str.charAt()</code> 返回在指定位置的字符</li>
<li><code>str.concat(str2)</code> 连接字符串</li>
<li><code>str.indexOf(str2)</code> 返回某个指定的字符串值在字符串中首次出现的位置</li>
<li><code>str.lastIndexOf(str2)</code> 返回一个指定的字符串在字符串中最后出现的位置，从后向前搜索</li>
<li><code>str.match(regexp)</code> 在字符串内找到一个或多个正则表达式的匹配，返回一个数组</li>
<li><code>str.replace(regexp/substr, str2)</code> 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串</li>
<li><code>str.search(regexp/substr)</code> 检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，返回相匹配的子串的起始位置</li>
<li><code>str.split()</code>，将字符串变为数组，以某符号分割。</li>
<li><code>str.slice(start,end)</code> 返回一个新的字符串。从 start 开始（包括 start）到 end 结束（不包括 end）。</li>
<li><code>str.substr(start, length)</code> 抽取从 start 下标开始的指定数目的字符。</li>
<li><code>str.substring(start, end)</code> 返回一个新的字符串, 子串包括 start 处的字符，但不包括 stop 处的字符, 与slice() 和 substr() 方法不同的是，substring() 不接受负的参数。</li>
<li><code>str.toLowerCase()</code>    把字符串转换为小写。</li>
<li><code>str.toUpperCase()</code>    把字符串转换为大写。</li>
</ol>
<h2 id="ES6新增字符串操作"><a href="#ES6新增字符串操作" class="headerlink" title="ES6新增字符串操作"></a>ES6新增字符串操作</h2><ol>
<li><code>str.includes(str)</code> 返回布尔值，表示是否找到了参数字符串。</li>
<li><code>str.startsWith(str)</code> 返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><code>str.endsWith(str)</code> 返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
<li><code>str.repeat(n)</code> 方法返回一个新字符串，表示将原字符串重复n次。n为0则返回空串</li>
<li><code>str.padStart(n, str)</code>，<code>str.padEnd(n, str)</code> 字符串补全长度。如果某个字符串不够指定长度，会在头部或尾部补全。</li>
<li><code>trimStart()</code>和<code>trimEnd()</code> 与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。</li>
</ol>
<h2 id="如何判断是否是数组？"><a href="#如何判断是否是数组？" class="headerlink" title="如何判断是否是数组？"></a>如何判断是否是数组？</h2><ol>
<li><code>Array.isArray(arr) // es6提供</code></li>
<li><code>Object.prototype.toString.call(arr) === &quot;[object Array]&quot;</code> </li>
<li><code>arr instanceof Array</code></li>
<li><code>arr.constructor === Array</code></li>
</ol>
<p>一般用1，2方法</p>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><ol>
<li><code>arr.push(a, b, c...)</code> 从后面添加一个或多个元素，返回值为添加完后的数组的长度</li>
<li><code>arr.pop()</code>  从后面删除元素，只能是一个，返回值是删除的元素</li>
<li><code>arr.shift()</code> 从前面删除元素，只能删除一个 返回值是删除的元素</li>
<li><code>arr.unshift(a, b, c...)</code> 从前面添加一个或多个元素, 返回值是添加完后的数组的长度。第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1</li>
<li><code>arr.slice(start, end)</code> 返回索引值start到索引值end的数组，不包含end元素，不改变原数组，如果不传参数，则返回它本身的副本。</li>
<li><code>arr.splice(i, n, item1,...,itemX)</code> 从数组中删除从i开始的n个元素，返回被删除的数组，还可以传入其他的值来替换被删除的数组项目</li>
<li><code>arr.join()</code> 将数组变为字符串，以传入的参数连接</li>
<li>易混淆的一个string的方法，<code>str.split()</code>，将字符串变为数组，以某符号分割</li>
<li><code>arr.concat(newArr)</code> 连接两个数组 返回值为连接后的新数组</li>
<li><code>arr.reverse()</code> 将数组反转，返回值是反转后的数组</li>
<li><code>arr.sort()</code> 将数组进行排序,返回值是排好的数组。默认将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。<br>如果传入了比较函数：<ul>
<li>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前</li>
<li>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变</li>
<li>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前  </li>
<li>总结： a-b 是升序，b-a是降序</li>
</ul>
</li>
<li><code>arr.forEach((value, index, arr) =&gt; { ... })</code> 遍历数组, 无return, 不改变原数组</li>
<li><code>arr.map((value, index, arr) =&gt; { ... })</code> 遍历数组, 返回一个新数组, 不改变原数组</li>
<li><code>arr.filter((value, index, arr) =&gt; { ... })</code> 过滤数组，返回一个满足要求的数组</li>
<li><code>arr.every((value, index, arr) =&gt; { ... })</code> 依据判断条件，数组的元素是否全满足，若满足则返回ture。全真则真，一假即假</li>
<li><code>arr.some((value, index, arr) =&gt; { ... })</code> 依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture。有真则真，全假才假</li>
<li><code>arr.reduce((total, value, index, arr) = &gt; { ... }, initValue)</code> 为数组中的每一个元素依次执行callback函数，并将函数的返回值作为total参数传给下次循环</li>
</ol>
<h2 id="ES6新增数组操作"><a href="#ES6新增数组操作" class="headerlink" title="ES6新增数组操作"></a>ES6新增数组操作</h2><ol>
<li><code>Array.from()</code> 将对象转为数组：string，arguments, Set, Map, key是数字的对象</li>
<li><code>Array.of()</code> 用于将一组值，转换为数组。<code>Array.of(3, 11, 8) // [3,11,8]</code></li>
<li><p><code>arr.copyWithin(target, start, end)</code> 将指定位置的成员(从start到end，不包含end的成员)复制到其他位置(从target开始)（会覆盖原有成员），然后返回当前数组。  </p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。</li>
<li><p>end（可选）：到该位置前停止读取数据，默认等于数组长度。</p>
<p><code>[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]</code>  用4，5把1，2替换<br><code>[1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5]</code> 用4把1替换</p>
</li>
</ul>
</li>
<li><code>arr.find((value, index, arr) =&gt; { ... })</code> 找出第一个符合条件的数组元素，然后返回该元素</li>
<li><code>arr.findIndex((value, index, arr) =&gt; { ... })</code> 找出第一个符合条件的数组元素，然后返回该元素的位置</li>
<li><code>arr.includes()</code> 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似</li>
<li><code>arr.entries()</code>，<code>arr.keys()</code>和<code>arr.values()</code>用于遍历数组。keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</li>
<li><code>arr.flat()</code> 用于将嵌套的数组“拉平”。默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以给flat()方法的参数传入一个整数，表示想要拉平的层数。<br> <code>[1, 2, [3, 4]].flat()   //[1, 2, 3, 4]</code><br> <code>[1, 2, [3, [4, 5]]].flat()   //[1, 2, 3, [4, 5]]</code><br> <code>[1, 2, [3, [4, 5]]].flat(2)   //[1, 2, 3, 4, 5]</code>  </li>
<li><code>arr.flatMap((value, index, arr) =&gt; { ... })</code> 先执行map，然后对返回值组成的新数组执行flat()方法。</li>
</ol>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>用Set, <code>let newArr = [..new Set(arr)]</code></p>
<p>如果是对象，用reduce<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temArr = [];</span><br><span class="line"><span class="keyword">const</span> uniqueList = totalList.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!temArr.includes(next.id)) &#123;</span><br><span class="line">        temArr.push(next.id);</span><br><span class="line">        prev.push(next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></p>
<h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><p>concat, […a, …b]扩展运算符</p>
<h2 id="数组循环中删除元素"><a href="#数组循环中删除元素" class="headerlink" title="数组循环中删除元素"></a>数组循环中删除元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === target) &#123;</span><br><span class="line">        arr.splice(i, <span class="number">1</span>);</span><br><span class="line">        i = i <span class="number">-1</span>; <span class="comment">// 一定要给下标重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数内部-arguments-变量有哪些特性-有哪些属性-如何将它转换为数组"><a href="#函数内部-arguments-变量有哪些特性-有哪些属性-如何将它转换为数组" class="headerlink" title="函数内部 arguments 变量有哪些特性,有哪些属性,如何将它转换为数组"></a>函数内部 arguments 变量有哪些特性,有哪些属性,如何将它转换为数组</h2><p>arguments对象是所有（非箭头）函数中都可用的局部变量。可以使用arguments[i]引用函数的参数，也可以修改函数参数。修改的只是函数的形参，并不会影响实参。  </p>
<ul>
<li><code>arguments.callee</code> 指向当前执行的函数。  </li>
<li><code>arguments.caller</code> 指向调用当前函数的函数。  </li>
<li><code>arguments.length</code> 指向传递给当前函数的参数数量。</li>
</ul>
<p>转换为数组：  </p>
<ol>
<li><code>var arr = [...arguments];</code></li>
<li><code>Array.prototype.slice.call(arguments);</code></li>
<li><code>Array.from(arguments)</code></li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>工厂：工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。</li>
<li>单例：保证每次访问得到的都是同一个对象，可以用全局对象存储。</li>
<li>适配器：为了解决两个接口不兼容的情况，通过包装一层实现两个接口正常协作。</li>
<li>装饰模式：不需要改变已有的接口，作用是给对象添加功能。</li>
<li>代理模式：代理是为了控制对对象的访问，不让外部直接访问到对象。代理类可以访问并操作对象，然后暴露相关方法供外部调用。</li>
<li>发布订阅（观察者）模式：当对象发生改变时，订阅方都会收到通知。先定义一个对象，这个对象包含on方法和trigger方法，以及一个存储回调函数的list。on的时候往list里面push，trigger的时候再从list中拿出来并执行。</li>
</ul>
<h2 id="jquery插件开发"><a href="#jquery插件开发" class="headerlink" title="jquery插件开发"></a>jquery插件开发</h2><p>其实就是给jquery增加一种新的方法。  </p>
<ol>
<li><p>一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jQuery.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    alert(<span class="string">'This is a test.'</span>);   </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 或 </span></span><br><span class="line">jQuery.extend(&#123;      </span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;      </span><br><span class="line">        alert(<span class="string">'This is a test.'</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 但是一般我们都加上命名空间去使用</span></span><br><span class="line">jQuery.myPlugin = &#123;           </span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;           </span><br><span class="line">        alert(<span class="string">'This is a test.'</span>);           </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">jQuery.foo();</span><br><span class="line">$.foo();</span><br><span class="line">$.myPlugin.foo();</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种是对象级别的插件开发，即给jQuery对象添加方法。这就需要把方法添加到jQuery的prototype上。查看jQuery源码可以发现jQuery.fn=jQuery.prototype。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.fn.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'this is test2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 为了满足链式调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">$.fn.extends(&#123;</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'this is test2'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 但一般我们为了防止$.fn被其他库污染，都用立即执行函数定义</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    $.fn.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'this is test2'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(jQuery));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="jquery绑定事件，取消绑定，触发事件"><a href="#jquery绑定事件，取消绑定，触发事件" class="headerlink" title="jquery绑定事件，取消绑定，触发事件"></a>jquery绑定事件，取消绑定，触发事件</h2><p>on, off, trigger</p>
<h2 id="前端模块化的发展历程"><a href="#前端模块化的发展历程" class="headerlink" title="前端模块化的发展历程"></a>前端模块化的发展历程</h2><ol>
<li><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>立即执行函数定义模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> utilModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'utilModule'</span>;</span><br><span class="line">  <span class="built_in">module</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">module</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">utilModule.getName() <span class="comment">// "utilModule"</span></span><br><span class="line">utilModule.setName(<span class="string">'test'</span>)</span><br><span class="line">utilModule.getName() <span class="comment">// "test"</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>Nodejs的模块规范, 用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'testModule'</span>;</span><br><span class="line"><span class="keyword">var</span> setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    setName,</span><br><span class="line">    getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> testModule = <span class="built_in">require</span>(<span class="string">'./module.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(testModule.getName()); <span class="comment">// testModule</span></span><br><span class="line">testModule.setName(<span class="string">'test'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testModule.getName()); <span class="comment">// test</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>require.js遵循了这个规范。通过define方法去定义模块，通过require方法去加载模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="comment">// 定义独立的模块</span></span><br><span class="line">define(&#123;</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'this is test1'</span>); &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="comment">// 另一种定义独立模块的方式</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'this is test2'</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.js</span></span><br><span class="line"><span class="comment">// 定义非独立的模块（这个模块依赖其他模块）</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            a.test();</span><br><span class="line">            b.test();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'./c'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    c.test();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script src=<span class="string">"require.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"main.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台</span></span><br><span class="line"><span class="keyword">this</span> is test1</span><br><span class="line"><span class="keyword">this</span> is test2</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>seajs遵循了这个规范。通过define方法去定义模块，通过seajs.use去加载模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'this is test1'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123; test &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'this is test2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123; test &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">    <span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a.test();</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123; test &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">seajs.use(<span class="string">'./c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    c.test();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script src=<span class="string">"sea.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"main.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台</span></span><br><span class="line"><span class="keyword">this</span> is test1</span><br><span class="line"><span class="keyword">this</span> is test2</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span></span><br><span class="line"><span class="keyword">import</span> </span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ...</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>UMD是同时支持AMD和CommonJS的规范。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    <span class="comment">// 如果环境中有define函数，并且define函数具备amd属性，则可以判断当前环境满足AMD规范</span></span><br><span class="line">    define([<span class="string">"test"</span>], factory());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> exports === <span class="string">"object"</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 是commonjs模块规范，nodejs环境</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 浏览器全局变量(root 即 window)</span></span><br><span class="line">    root.umdModule = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">"我是一个umd模块"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="AMD-和-CMD-的区别"><a href="#AMD-和-CMD-的区别" class="headerlink" title="AMD 和 CMD 的区别"></a>AMD 和 CMD 的区别</h2><ol>
<li>对于依赖的模块，AMD 是提前加载，CMD 是延迟加载。</li>
<li>从规范上，CMD更贴近CommonJS的异步模块化方案</li>
</ol>
<h2 id="ES6-模块和-CommonJS-模块的区别"><a href="#ES6-模块和-CommonJS-模块的区别" class="headerlink" title="ES6 模块和 CommonJS 模块的区别"></a>ES6 模块和 CommonJS 模块的区别</h2><ol>
<li>commonJS 模块输出的是一个值的拷贝，ES6模块输出的是值的引用  <ul>
<li>commonJS模块一旦输出一个值，模块内部的变化就影响不到这个值。  </li>
<li>ES6模块如果使用import从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，原始值变了，import加载的值也会跟着变。  </li>
</ul>
</li>
<li>commonJS 模块是运行时加载，ES6 模块是静态编译时加载，所有可以用于tree shaking<ul>
<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>
<li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>
</ul>
</li>
<li>CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载</li>
</ol>
<p>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<h2 id="module-exports和exports的区别"><a href="#module-exports和exports的区别" class="headerlink" title="module.exports和exports的区别"></a>module.exports和exports的区别</h2><ol>
<li>exports是module.exports的引用, 即<br> <code>var exports=module.exports</code></li>
<li>初始时这两个变量是指向同一个空对象</li>
<li>当执行完毕时只有module.exports会被返回。</li>
</ol>
<p>所以</p>
<ol>
<li>当你想导出的东西可以在空对象上直接扩展就可以的时候，用exports当然省时省力</li>
<li>当你想导出的东西要完全覆盖掉空对象的时候，只能用module.exports了</li>
<li>当你分不清楚的时候请用module.exports</li>
</ol>
</div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-nav"><a class="pre" href="/2022/01/11/1/Vue/">Vue</a><a class="next" href="/2022/01/11/1/性能优化/">性能优化</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'cXa2hNBumN2DUEHc5sMwqmAR-gzGzoHsz',
  appKey:'k25vMV7ayuuHBhTaLWsiFGXp',
  placeholder:'ヾﾉ≧∀≦)o欢迎你的评论~~~',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://cuiqs.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/八股文/">八股文</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/">学习</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/防火墙/" style="font-size: 15px;">防火墙</a> <a href="/tags/OKR/" style="font-size: 15px;">OKR</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/浏览器/" style="font-size: 15px;">浏览器</a> <a href="/tags/Webkit/" style="font-size: 15px;">Webkit</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/virtualenv/" style="font-size: 15px;">virtualenv</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/ubuntu-nginx/" style="font-size: 15px;">ubuntu nginx</a> <a href="/tags/抓取网页/" style="font-size: 15px;">抓取网页</a> <a href="/tags/webpack4/" style="font-size: 15px;">webpack4</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/Webpack/" style="font-size: 15px;">Webpack</a> <a href="/tags/Vue3-Vite/" style="font-size: 15px;">Vue3-Vite</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/网络与安全/" style="font-size: 15px;">网络与安全</a> <a href="/tags/软性/" style="font-size: 15px;">软性</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/CSS/">CSS</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/HTML/">HTML</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/React/">React</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/Webpack/">Webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/vue3-vite/">Vue3-Vite</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/Vue/">Vue</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/JavaScript/">JavaScript</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/性能优化/">性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/ES6/">ES6</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/浏览器/">浏览器</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">不着急.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>