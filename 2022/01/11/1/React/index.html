<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="吾心自足，心无外物，时时可死。步步求生，纵横四海，心无挂碍。"><title>React | 不着急</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">React</h1><a id="logo" href="/.">不着急</a><p class="description">吾心自足，心无外物，时时可死。步步求生，纵横四海，心无挂碍。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/yys/"><i class="fa fa-lab"> lab</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">React</h1><div class="post-meta">Jan 11, 2022<span> | </span><span class="category"><a href="/categories/八股文/">八股文</a></span></div><a class="disqus-comment-count" href="/2022/01/11/1/React/#vcomment"><span class="valine-comment-count" data-xid="/2022/01/11/1/React/"></span><span> 条评论</span></a><div class="post-content"><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p>虚拟dom就是一个普通的javascript对象，一般包含tag，props，children三个属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>hello world!!!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>转化成虚拟dom<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id: <span class="string">'app'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">'p'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        className: <span class="string">'text'</span></span><br><span class="line">      &#125;</span><br><span class="line">      children: <span class="string">'hello world!!!'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="虚拟dom是如何工作的"><a href="#虚拟dom是如何工作的" class="headerlink" title="虚拟dom是如何工作的"></a>虚拟dom是如何工作的</h2><ul>
<li>当数据发生变化，比如setState时，会引起组件重新渲染，react会重新构建虚拟dom树(以该组件为根，重新渲染整个组件子树)。</li>
<li>diff新dom树与旧dom树的差异。</li>
<li>最后将差异更新到真实的dom。</li>
</ul>
<p>将虚拟DOM树转换成真实DOM树的最少操作的过程 称为 调和 。</p>
<h2 id="react-diff-工作原理"><a href="#react-diff-工作原理" class="headerlink" title="react diff 工作原理"></a>react diff 工作原理</h2><p>diff算法的作用是计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面。</p>
<p>传统diff算法<br>通过循环递归对节点进行依次对比，算法复杂度达到 O(n^3)。为了解决这个问题，React中定义了三种策略，在对比时，根据策略只需遍历一次树就可以完成对比，将复杂度降到了O(n)</p>
<h3 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h3><ol>
<li>tree diff: 在两个树对比时，只会比较同一层级的节点，会忽略掉跨层级的操作。</li>
<li>component diff: 拥有相同类的两个组件将会生成相似的树形结构， 拥有不同类的两个组件会生成不同的树形结构。</li>
<li>element diff: 对于同一层级的一组节点，可以通过唯一id来区分。<h3 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h3></li>
</ol>
<ul>
<li>对树进行分层比较，两棵树只会对同一层次的节点进行比较。</li>
<li>如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。</li>
<li>只需遍历一次，就能完成整棵DOM树的比较。</li>
<li>diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作(先创建再删除)。因此 官方建议不要进行DOM节点跨层级操作，可以通过CSS隐藏、显示节点，而不是真正地移除、添加DOM节点。<h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3></li>
<li>同一类型的两个组件，按原策略（层级比较）继续比较Virtual DOM树即可。</li>
<li>同一类型的两个组件，组件A变化为组件B时，可能Virtual DOM没有任何变化，如果知道这点（变换的过程中，Virtual DOM没有改变），可节省大量计算时间，所以 用户 可以通过 shouldComponentUpdate() 来判断是否需要更新。</li>
<li>不同类型的组件，将一个（将被改变的）组件判断为dirty component（脏组件），从而替换 整个组件的所有节点。删除组件， 创建新组件。<h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3></li>
<li>同一级节点比较时，diff提供三种节点操作：删除、插入、移动。同一节点有唯一的key。</li>
<li>删除： 直接删除节点</li>
<li>插入： 插入节点</li>
<li>移动： 根据key进行移动</li>
</ul>
<h2 id="Vue-和-React-的-Diff-算法有哪些区别"><a href="#Vue-和-React-的-Diff-算法有哪些区别" class="headerlink" title="Vue 和 React 的 Diff 算法有哪些区别"></a>Vue 和 React 的 Diff 算法有哪些区别</h2><p>相同点：</p>
<ol>
<li>都只对同级节点进行对比</li>
<li>都用key做为标识</li>
</ol>
<p>不同点：</p>
<ol>
<li>列表对比，react 采用单指针从左向右进行遍历，vue采用双指针，从两头向中间进行遍历。</li>
<li>节点对比，当节点元素类型相同，但是className不同，vue认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性。</li>
</ol>
<h2 id="vue和react的区别"><a href="#vue和react的区别" class="headerlink" title="vue和react的区别"></a>vue和react的区别</h2><ol>
<li>模板 与 JSX</li>
<li>复用 mixin与HOC， hooks和setup</li>
<li>通信方面 <ul>
<li>父子，vue, data down, event up. react props 和 callback</li>
<li>同级，provide/inject, context</li>
</ul>
</li>
<li>数据绑定， vue双向，v-modal. react单向</li>
</ol>
<h2 id="React-中-keys-的作用是什么？"><a href="#React-中-keys-的作用是什么？" class="headerlink" title="React 中 keys 的作用是什么？"></a>React 中 keys 的作用是什么？</h2><p>key是react元素或组件的唯一标识，用于diff的时候，追踪元素或组件的删除，插入，移动等。</p>
<h2 id="触发多次setstate，那么render会执行几次？"><a href="#触发多次setstate，那么render会执行几次？" class="headerlink" title="触发多次setstate，那么render会执行几次？"></a>触发多次setstate，那么render会执行几次？</h2><p>多次setState会合并为一次render，因为setState并不会立即改变state的值，而是将其放到一个任务队列里，最终将多个setState合并，一次性更新页面</p>
<h2 id="setState为什么异步？能不能同步？什么时候异步？什么时候同步？"><a href="#setState为什么异步？能不能同步？什么时候异步？什么时候同步？" class="headerlink" title="setState为什么异步？能不能同步？什么时候异步？什么时候同步？"></a>setState为什么异步？能不能同步？什么时候异步？什么时候同步？</h2><ul>
<li>setState只在合成事件和钩子函数中是异步的，在原生事件与setTimeout中都是同步的</li>
<li>setState本身的执行都是同步的，并不是由异步代码实现。只是因为合成事件和钩子函数的执行顺序在更新之前，所以合成事件和钩子函数中无法拿到更新后的值。形成了异步。可以通过setState的第二个callback参数拿到更新后的值。</li>
<li>在合成事件与钩子函数中会对多次setState进行更新优化，只执行最后一次；在原生事件与setTimeout内不会进行批量更新优化；</li>
</ul>
<h2 id="React-中什么是合成事件"><a href="#React-中什么是合成事件" class="headerlink" title="React 中什么是合成事件"></a>React 中什么是合成事件</h2><p>React 合成事件（SyntheticEvent）是 React 模拟原生 DOM 事件所有能力的一个事件对象。即浏览器原生事件的跨浏览器包装器。它根据 W3C 规范 来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口。</p>
<p>在 React 中，“合成事件”会以事件委托（Event Delegation）方式绑定在组件最上层，并在组件卸载（unmount）阶段自动销毁绑定的事件。</p>
<p>一般如果 DOM 上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React 为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。</p>
<p>合成事件的一套机制：React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 documnet 上面，然后 React 将事件封装给正式的函数处理运行和处理</p>
<ol>
<li>当用户在为 onClick 添加函数时，React 并没有将 Click 事件绑定在 DOM 上面</li>
<li>而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层 SynthticEvent(负责所有事件合成)</li>
<li>所以当事件触发的时候，对使用统一的分发函数 dispatchEvent 将指定函数执行</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000039108951" target="_blank" rel="noopener">https://segmentfault.com/a/1190000039108951</a></p>
<h3 id="那么-React-为什么使用合成事件？其主要有三个目的："><a href="#那么-React-为什么使用合成事件？其主要有三个目的：" class="headerlink" title="那么 React 为什么使用合成事件？其主要有三个目的："></a>那么 React 为什么使用合成事件？其主要有三个目的：</h3><ol>
<li><p>进行浏览器兼容，实现更好的跨平台</p>
<p> React 采用的是顶层事件代理机制，能够保证冒泡一致性，可以跨浏览器执行。React 提供的合成事件用来抹平不同浏览器事件对象之间的差异，将不同平台事件模拟合成事件。</p>
</li>
<li><p>避免垃圾回收</p>
<p> 事件对象可能会被频繁创建和回收，因此 React 引入事件池，在事件池中获取或释放事件对象。即 React 事件对象不会被释放掉，而是存放进一个数组中，当事件触发，就从这个数组中弹出，避免频繁地去创建和销毁(垃圾回收)。</p>
</li>
<li><p>方便事件统一管理和事务机制</p>
</li>
</ol>
<h2 id="类组件和函数组件之间的区别是啥（不考虑hook）？"><a href="#类组件和函数组件之间的区别是啥（不考虑hook）？" class="headerlink" title="类组件和函数组件之间的区别是啥（不考虑hook）？"></a>类组件和函数组件之间的区别是啥（不考虑hook）？</h2><ol>
<li>类组件有state和生命周期， 函数式组件又叫无状态组件， 没有state和生命周期。</li>
<li>类组件使用时需要先实例化， 函数式组件不能实例化，他是一个函数， 传参， 执行，返回结果。</li>
<li>无状态组件由于没有实例化过程，所以无法访问组件this中的对象。</li>
</ol>
<h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><p>hooks为函数组件提供了状态，也支持在函数组件中获取数据等。</p>
<ul>
<li>只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3>在函数式组件中使用state<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3></li>
<li>执行副作用操作，比如请求数据， 绑定解绑事件，设置取消定时器等。</li>
<li>默认第一次渲染和每次更新都会执行useEffect</li>
<li>如果想只第一次渲染执行，依赖项传空数组。数组不为空时，将会依赖项变化后执行。</li>
<li>可以返回一个函数来清楚副作用。将会在组件卸载时执行。<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3>用于缓存函数，如果依赖项发生了变化，该函数才发生变化。一般用于将此函数传入子组件中，因为默认每次父组件更新，传入子组件的该函数都不一样。配合React.memo()一起使用<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3>用于缓存函数返回值。如果依赖项发生变化，该函数才重新执行，计算返回值。一般用于该函数比较复杂，开销较大。避免每次更新此函数都重新执行。<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3></li>
<li>ref 用来获取类组件实例，或者DOM对象</li>
<li>useRef 用来创建ref对象</li>
<li>通过 ref={myRef} 绑定在DOM 对象或者React组件上</li>
<li>通过 this.myRef.current 访问DOM对象或者class组件的实例</li>
<li>useRef()可以用来保存一个不变的值。简单来说，我们可以将useRef返回值看作一个组件内部全局共享变量，它会在多次渲染内部共享一个相同的值。</li>
</ul>
<h2 id="如何创建-refs"><a href="#如何创建-refs" class="headerlink" title="如何创建 refs"></a>如何创建 refs</h2><ul>
<li>类组件中： <code>this.myRef = React.createRef();</code></li>
<li>函数式组件中： <code>const ref = useRef();</code></li>
<li>或者在类组件中通过回调函数： <code>&lt;input type=&#39;text&#39; ref={(input) =&gt; this.input = input} /&gt;</code></li>
</ul>
<h2 id="用React-hook实现一个计数器组件"><a href="#用React-hook实现一个计数器组件" class="headerlink" title="用React hook实现一个计数器组件"></a>用React hook实现一个计数器组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fucntion Counter() &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">count</span> =&gt;</span> count+<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何实现一个自定义hook，useEventListener"><a href="#如何实现一个自定义hook，useEventListener" class="headerlink" title="如何实现一个自定义hook，useEventListener"></a>如何实现一个自定义hook，useEventListener</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEventListener</span>(<span class="params">eventName, handler, dom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> savedHandler = useRef();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    savedHandler.current = handler;</span><br><span class="line">  &#125;, [handler]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventListener = <span class="function">(<span class="params">event</span>) =&gt;</span> savedHandler.current(event);</span><br><span class="line">    dom.addEventLister(eventName, eventListener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dom.removeEventListener(eventName, eventListener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [eventName, dom])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="useEffect中如何使用async-await"><a href="#useEffect中如何使用async-await" class="headerlink" title="useEffect中如何使用async/await"></a>useEffect中如何使用async/await</h2><p>在useEffect内部或者外部，重新封装一个async函数，在async函数内部使用await。在useEffect里面调用这个async函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchMyAPI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">"api/data"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  fetchMyAPI();</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fetchMyAPI = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">"api/data"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fetchMyAPI();</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></p>
<h2 id="react-hooks-的原理是什么"><a href="#react-hooks-的原理是什么" class="headerlink" title="react hooks 的原理是什么"></a>react hooks 的原理是什么</h2><p>闭包</p>
<h2 id="state-和-props-的区别是什么"><a href="#state-和-props-的区别是什么" class="headerlink" title="state 和 props 的区别是什么"></a>state 和 props 的区别是什么</h2><ul>
<li>props和state都是普通的 JS 对象</li>
<li>state 是组件内部状态，可变</li>
<li>props 是外部传入的参数， 不可变</li>
</ul>
<h2 id="什么是受控组件"><a href="#什么是受控组件" class="headerlink" title="什么是受控组件"></a>什么是受控组件</h2><p>在html中，表单元素如input, textarea，通常自己维护自己的状态，由用户输入自动更新。他们都是有自己的value的，这些元素是可以被直接设置value属性值的。 </p>
<p>但在React中，数据是单向的，所以不应该直接去修改这种组件的属性值，而应该用组件内部的state中的值。对于这种遵从React规定，使用state为唯一数据源，被 React 控制取值赋值的表单元素，我们称为受控组件。</p>
<ul>
<li>state中包含这个表单元素的value值</li>
<li>这个表单元素的value值要取自state中的value</li>
<li>元素value改变时，要赋值给state中的value，通过setState</li>
<li>通过e.target.value获取元素的value<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            value: e.target.value.toUpperCase()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="什么是jsx"><a href="#什么是jsx" class="headerlink" title="什么是jsx"></a>什么是jsx</h2><p>jsx将html和js混在一起编写，需要通过babel和webpack编译来转化成js。</p>
<ul>
<li>在html中可以写任何的js</li>
<li>js变量或者js表达式，语句，要用大括号{}包裹</li>
<li>html标签的属性值可以直接用双引号包裹字符串，也可以用大括号包裹js表达式</li>
<li>html标签的属性名使用驼峰命名，如html 的class，在JSX中是<code>className</code></li>
<li>如果标签没有内容， 可以用 <code>/&gt;</code> 来闭合标签</li>
<li>事件的命名也使用驼峰命名，而不是纯小写。如html中的onclick，在JSX中是onClick</li>
<li>事件处理应该传入一个函数作为事件处理函数，而不是一个字符串</li>
<li>JSX 可以赋值给变量，也可以把 JSX 当作参数传入，以及从函数中返回 JSX</li>
<li>组件名称必须以大写字母开头，React会将以小写字母开头的组件视为原生DOM标签</li>
<li>注释也要用{}包裹</li>
</ul>
<h2 id="如何避免组件的重新渲染？"><a href="#如何避免组件的重新渲染？" class="headerlink" title="如何避免组件的重新渲染？"></a>如何避免组件的重新渲染？</h2><ul>
<li>React.memo(): 这可以防止不必要地重新渲染函数组件。对子组件默认使用浅比较对比前后两次 props 的变更，若未发生变更则不会重新渲染。</li>
<li>PureComponent: 这可以防止不必要地重新渲染类组件。对子组件默认使用浅比较对比前后两次 props 的变更。</li>
</ul>
<h2 id="为什么要给所有的实例方法绑定this呢？"><a href="#为什么要给所有的实例方法绑定this呢？" class="headerlink" title="为什么要给所有的实例方法绑定this呢？"></a>为什么要给所有的实例方法绑定this呢？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToggleButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    handleClick()&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">            isToggleOn: !preveState.isToggleOn</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">          &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">              &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="string">'ON'</span>:<span class="string">'OFF'</span>&#125;</span><br><span class="line">          &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>为了提前规避this指针丢失的问题，不然在程序执行过程中this就可能会指向window而不是该实例。</p>
<p>可以使用箭头函数， 他会默认指向上下文。</p>
<p>React在事件发生时调用onClick，由于onClick只是中间变量，如果不绑定this, 所以处理函数中的this指向会丢失。其实真正调用时并不是this.handleClick(),如果是这样调用那么this指向就不会有问题。真正调用的是onClick()，而onclick是dom事件，并不是类中的方法，简单可以理解为是在类外面的调用，此时的this其实指向的是全局作用域，而这个作用域下并没有setstate方法，所以自然而然地报undefined错误。</p>
<h2 id="react组件通信"><a href="#react组件通信" class="headerlink" title="react组件通信"></a>react组件通信</h2><h3 id="父组件向子组件通信"><a href="#父组件向子组件通信" class="headerlink" title="父组件向子组件通信"></a>父组件向子组件通信</h3><p>父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。</p>
<h3 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h3><p>父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。</p>
<h3 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h3><p>使用context</p>
<h3 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h3><ol>
<li>利用二者共同父组件的 context 对象进行通信</li>
<li>自定义event bus</li>
<li>redux</li>
</ol>
<h2 id="react性能优化"><a href="#react性能优化" class="headerlink" title="react性能优化"></a>react性能优化</h2><ul>
<li>render里面尽量减少新建变量和bind函数，传递参数时尽量减少传递参数的数量。</li>
<li>定制shouldComponentUpdate函数</li>
<li>React.memo 和 React.PureComponent</li>
<li>key不要用index</li>
<li>useMemo, useCallback</li>
</ul>
<h2 id="组件插槽"><a href="#组件插槽" class="headerlink" title="组件插槽"></a>组件插槽</h2><p>使用props.children<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;Parent&gt;</span><br><span class="line">    &lt;h1&gt;<span class="keyword">this</span> is children&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Parent&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;below is children&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &#123;props.children&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="React组件生命周期"><a href="#React组件生命周期" class="headerlink" title="React组件生命周期"></a>React组件生命周期</h2><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p>constructor()<br>static getDerivedStateFromProps() 从props中获取state，将传入的props映射到state<br>render()<br>componentDidMount()</p>
<h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>static getDerivedStateFromProps()  从props中获取state，将传入的props映射到state<br>shouldComponentUpdate()<br>render()<br>getSnapshotBeforeUpdate()<br>componentDidUpdate()  </p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>componentWillUnmount()</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>static getDerivedStateFromError()<br>componentDidCatch()</p>
<h2 id="如何在-hooks-中实现-shouldComponentUpdate-这个生命周期"><a href="#如何在-hooks-中实现-shouldComponentUpdate-这个生命周期" class="headerlink" title="如何在 hooks 中实现 shouldComponentUpdate 这个生命周期"></a>如何在 hooks 中实现 shouldComponentUpdate 这个生命周期</h2><p>React.memo默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure></p>
<h2 id="代码分割-组件懒加载"><a href="#代码分割-组件懒加载" class="headerlink" title="代码分割, 组件懒加载"></a>代码分割, 组件懒加载</h2><p>import()， React.lazy()</p>
<h2 id="怎么开发错误边界组件"><a href="#怎么开发错误边界组件" class="headerlink" title="怎么开发错误边界组件"></a>怎么开发错误边界组件</h2><p>如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界组件。</p>
<h2 id="使用-PropTypes-进行类型检查"><a href="#使用-PropTypes-进行类型检查" class="headerlink" title="使用 PropTypes 进行类型检查"></a>使用 PropTypes 进行类型检查</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Component.propTypes = &#123;</span><br><span class="line">  name: PropTypes.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="如何创建，使用Context"><a href="#如何创建，使用Context" class="headerlink" title="如何创建，使用Context"></a>如何创建，使用Context</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initValue = &#123;<span class="attr">a</span>: <span class="string">'test'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext(a)</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;MyContext.Provider value=&#123;initValue&#125;&gt;</span><br><span class="line">  &lt;Son /&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 后代组件中， hook写法</span></span><br><span class="line"><span class="regexp">const initValue = useContext(MyContext);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Class组件中使用</span></span><br><span class="line"><span class="regexp">Son.contextType = MyContext /</span><span class="regexp">/ 先挂载在类上</span></span><br><span class="line"><span class="regexp">this.context /</span><span class="regexp">/ 组件中就可以使用</span></span><br></pre></td></tr></table></figure>
<h2 id="render-prop"><a href="#render-prop" class="headerlink" title="render prop"></a>render prop</h2><p>render prop组件， 将渲染逻辑改成方法传入， 而不是写死， 可以做到动态渲染。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 render prop组件</span></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用</span></span><br><span class="line"><span class="regexp">&lt;MyComponent render=&#123;(data) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  &lt;h1&gt;Hello &#123;data&#125;&lt;/</span>h1&gt;</span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="什么是高阶组件HOC"><a href="#什么是高阶组件HOC" class="headerlink" title="什么是高阶组件HOC"></a>什么是高阶组件HOC</h2><p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">higherOrderComponent</span>(<span class="params">wrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOCComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;wrappedComponent.displayName&#125;</span>)`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line">      <span class="comment">// 操作state</span></span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        name:<span class="string">'alien'</span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作props</span></span><br><span class="line">    <span class="keyword">let</span> newProps = &#123; ...this.props, <span class="attr">title</span>: <span class="string">'new title'</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...newProps</span>&#125; &#123; <span class="attr">...this.state</span> &#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="高阶组件可以用来做什么"><a href="#高阶组件可以用来做什么" class="headerlink" title="高阶组件可以用来做什么"></a>高阶组件可以用来做什么</h2><ul>
<li>代码重用、逻辑和引导抽象</li>
<li>渲染劫持</li>
<li>state 抽象和操作</li>
<li>props 处理</li>
</ul>
<h2 id="React-中各种组件复用的优劣势（mixin、render-props、hoc、hook）"><a href="#React-中各种组件复用的优劣势（mixin、render-props、hoc、hook）" class="headerlink" title="React 中各种组件复用的优劣势（mixin、render props、hoc、hook）"></a>React 中各种组件复用的优劣势（mixin、render props、hoc、hook）</h2><p>mixins: 变量来源不清、属性重名、Mixins引入过多会导致顺序冲突</p>
<p>HOC：优点：提取公共逻辑，降低耦合度。缺点：组件嵌套过多，调试溯源不清晰，state、内部方法相同的话会进行覆盖。</p>
<p>Render props：优点：清楚知道这个state来自哪里。缺点：使用起来会嵌套地狱。不能在return外使用数据。</p>
<p>hook: Hooks 就是让你不必写class组件就可以用state和其他的React特性；也可以编写自己的hooks在不同的组件之间复用。代码量少，复用性高，易拆分，也有一些闭包的坑</p>
<h2 id="React-路由有3种渲染方式——render，children，component，到底用哪一个？用任何一个都可以吗？"><a href="#React-路由有3种渲染方式——render，children，component，到底用哪一个？用任何一个都可以吗？" class="headerlink" title="React 路由有3种渲染方式——render，children，component，到底用哪一个？用任何一个都可以吗？"></a>React 路由有3种渲染方式——render，children，component，到底用哪一个？用任何一个都可以吗？</h2><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>给 render 传递的是一个函数，它和 component 一样，在函数的参数中可以访问到所有的 route props<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内联方式</span></span><br><span class="line">&lt;Route path=<span class="string">"path"</span> render=&#123;() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是内联组件写法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125; /&gt;</span><br><span class="line"><span class="comment">//嵌套组合方式</span></span><br><span class="line">&lt;Route path=<span class="string">"path"</span> render=&#123; props =&gt; (</span><br><span class="line">  &lt;ParentComp&gt;</span><br><span class="line">    &lt;Comp &#123;...props&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/ParentComp&gt;</span></span><br><span class="line"><span class="regexp">) /</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="children"><a href="#children" class="headerlink" title="children"></a>children</h3><p>无论 location 是否匹配路由，你都需要渲染一些内容，这时候你可以使用 children。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"path"</span> children=&#123; props =&gt; (</span><br><span class="line">  &lt;div className=&#123;props.match? <span class="string">"active"</span>: <span class="string">''</span>&#125;&gt;</span><br><span class="line">    &lt;Link to=<span class="string">"path"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">) /</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><p>只有在当 location 匹配时才渲染<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"path"</span> component=&#123;Comp&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>但当他们同时存在时，优先渲染component的值，其次是render属性的值，而children属性的值优先级最低，为了避免 不必要的错误，尽量每个Route中只是用他们三个中的其中一个。</p>
<h2 id="React-的-Fiber-是干什么的"><a href="#React-的-Fiber-是干什么的" class="headerlink" title="React 的 Fiber 是干什么的"></a>React 的 Fiber 是干什么的</h2><p>因为 JavaScript 单线程的特点，每个同步任务不能耗时太长，不然就会让程序不会对其他输入作出相应，React 的更新过程就是犯了这个禁忌，而 React Fiber 就是要改变现状。 而可以通过分片来破解 JavaScript 中同步操作时间过长的问题。</p>
<p>把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。</p>
<p>React Fiber 把更新过程碎片化，每执行完一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。</p>
<p>维护每一个分片的数据结构，就是 Fiber。</p>
<h2 id="React-性能优化"><a href="#React-性能优化" class="headerlink" title="React 性能优化"></a>React 性能优化</h2><ul>
<li>Code Splitting</li>
<li>shouldComponentUpdate 避免重复渲染</li>
<li>异步按需加载，路由懒加载，路由监听器</li>
<li>组件尽可能的进行拆分、解耦</li>
<li>列表类组件优化，<br>比如：shouldComponentUpdate(nextProps, nextState)：React.PureComponent、Immutable，React.memo</li>
<li>bind 函数优化</li>
<li>非可控组件和可控组件区别是否受 state 影响</li>
<li>ReactDOMServer 进行服务端渲染组件</li>
</ul>
</div><div class="tags"><a href="/tags/React/">React</a></div><div class="post-nav"><a class="pre" href="/2022/01/11/1/HTML/">HTML</a><a class="next" href="/2022/01/11/1/Webpack/">Webpack</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'cXa2hNBumN2DUEHc5sMwqmAR-gzGzoHsz',
  appKey:'k25vMV7ayuuHBhTaLWsiFGXp',
  placeholder:'ヾﾉ≧∀≦)o欢迎你的评论~~~',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://cuiqs.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/八股文/">八股文</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/学习/">学习</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/防火墙/" style="font-size: 15px;">防火墙</a> <a href="/tags/OKR/" style="font-size: 15px;">OKR</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/浏览器/" style="font-size: 15px;">浏览器</a> <a href="/tags/Webkit/" style="font-size: 15px;">Webkit</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/virtualenv/" style="font-size: 15px;">virtualenv</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/ubuntu-nginx/" style="font-size: 15px;">ubuntu nginx</a> <a href="/tags/抓取网页/" style="font-size: 15px;">抓取网页</a> <a href="/tags/webpack4/" style="font-size: 15px;">webpack4</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/Webpack/" style="font-size: 15px;">Webpack</a> <a href="/tags/Vue3-Vite/" style="font-size: 15px;">Vue3-Vite</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/网络与安全/" style="font-size: 15px;">网络与安全</a> <a href="/tags/软性/" style="font-size: 15px;">软性</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/CSS/">CSS</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/HTML/">HTML</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/React/">React</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/Webpack/">Webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/vue3-vite/">Vue3-Vite</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/Vue/">Vue</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/JavaScript/">JavaScript</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/性能优化/">性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/ES6/">ES6</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/11/1/浏览器/">浏览器</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">不着急.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>